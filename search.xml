<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[松索来金的软件]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%9D%BE%E7%B4%A2%E6%9D%A5%E9%87%91%E7%9A%84%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自己经常逛一些爱q或小刀网，发现上面的好多活动挺好，就打算看看有没有更多类似这种的，于是上网搜索，偶然间看到了这款软件 了解了下，感觉还不错就付费下载了下，玩了一段时间，那段时间也没做什么就是签到，到了今天发现居然回本了，就感慨下 我感觉还行，最近再看他们里面的原创文章，学习怎么建站 具体想要了解的话可以去百度，或者这个地址看看]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目常用方法]]></title>
    <url>%2F2019%2F04%2F10%2F%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149 // 隐藏手机号中间4位 formatPhone(phone) &#123; phone += &apos;&apos;; return phone.replace(/(\d&#123;3&#125;)\d*(\d&#123;4&#125;)/g, &apos;$1***$2&apos;) &#125;, // 隐藏身份证号中11位 formatIdentity(number) &#123; number += &apos;&apos;; return number.replace(/(\d&#123;3&#125;)\d*(\d&#123;4&#125;)/g, &apos;$1***********$2&apos;) &#125;, // 格式化金额,单位:分(eg:430分=4.30元) formatFee(fee, suffix = &apos;&apos;) &#123; if (!fee) &#123; return 0; &#125; return Number(fee).toFixed(2) + suffix; &#125;, // 格式化公里（eg:3000 = 3公里） formatMileage(mileage, text) &#123; if (!mileage) &#123; return 0; &#125; if (mileage &gt;= 1000) &#123; text = text || &quot; km&quot;; return Math.floor(mileage / 100) / 10 + text; &#125; else &#123; text = text || &quot; m&quot;; return mileage + text; &#125; &#125;, /* 邮箱校验*/export function isWscnEmail(str) &#123; const reg = /^[a-z0-9](?:[-_.+]?[a-z0-9]+)*@[a-z0-9]&#123;2,10&#125;\.[a-z]&#123;2,5&#125;$/i return reg.test(str.trim())&#125;/* 合法uri*/export function validateURL(textval) &#123; const urlregex = /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9]?[0-9]))&#123;3&#125;|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]&#123;2&#125;))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?&apos;\\+&amp;%$#=~_-]+))*$/ return urlregex.test(textval)&#125;/* 小写字母*/export function validateLowerCase(str) &#123; const reg = /^[a-z]+$/ return reg.test(str)&#125;/* 验证码*/export function validateAuthCode(str) &#123; const reg = /^[a-z]+$/ return reg.test(str)&#125;/* 大写字母*/export function validateUpperCase(str) &#123; const reg = /^[A-Z]+$/ return reg.test(str)&#125;/* 大小写字母*/export function validatAlphabets(str) &#123; const reg = /^[A-Za-z]+$/ return reg.test(str)&#125;/* 绑定地址验证*/export function validatOutAdress(str) &#123; if (typeof str === &apos;number&apos;) &#123; return false &#125; return /^[a-zA-Z\d]&#123;30,40&#125;$/.test(str)&#125;/* 手机验证*/export function validatPhone(str) &#123; const reg = /^1(3|4|5|6|7|8)\d&#123;9&#125;$/ return reg.test(str)&#125;/* Double型数据*/export function validatDouble(str) &#123; const reg = /^[-\+]?\d+(\.\d+)?$/ return reg.test(str)&#125;/* 只保留后四位*/export function validatLatterJudge(str) &#123; const reg = /^\d+(\.\d&#123;1,4&#125;)?$/ if (str.toString().length &gt; 10 &amp;&amp; str.toString().indexOf(&apos;.&apos;) == -1) &#123; return false &#125; if (str.toString().indexOf(&apos;.&apos;) &gt; -1) &#123; const index = str.toString().indexOf(&apos;.&apos;) if (index &gt; 10) &#123; return false &#125; else &#123; return reg.test(str) &#125; &#125; else &#123; return reg.test(str) &#125;&#125;/* 只保留小数点后8位*/export function validatLatterEight(str) &#123; const reg = /^\d+(\.\d&#123;1,8&#125;)?$/ // 判断小数点前几位 if (str.toString().length &gt; 10 &amp;&amp; str.toString().indexOf(&apos;.&apos;) == -1) &#123; return false &#125; if (str.toString().indexOf(&apos;.&apos;) &gt; -1) &#123; const index = str.toString().indexOf(&apos;.&apos;) if (index &gt; 10) &#123; return false &#125; else &#123; return reg.test(str) &#125; &#125; else &#123; return reg.test(str) &#125;&#125;// 验证是否是大于6位数小于20位的数字export function isDY6Num(pone) &#123; const reg = /^[0-9\d]&#123;6,20&#125;$/ return reg.test(pone)&#125;// 判断数组是否在数组中export function contains(arr, val) &#123; return arr.indexOf(val) !== -1&#125;// 数组排序export function sort(arr, type = 1) &#123; return arr.sort((a, b) =&gt; &#123; switch (type) &#123; case 1: return a - b case 2: return b - a case 3: return Math.random() - 0.5 default: return arr &#125; &#125;)&#125;]]></content>
      <categories>
        <category>-vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex事例]]></title>
    <url>%2F2019%2F04%2F10%2Fflex%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[flex布局练习 html, body { height: 100%; } body { display: flex; background: linear-gradient(top, #222, #333); background: -webkit-linear-gradient(top, #222, #333); justify-content: center; align-items: center; flex-wrap: wrap; align-content: center; } [class$="face"] { display: flex; margin: 14px; width: 104px; height: 104px; padding: 4px; background: #e7e7e7; border-radius: 10%; box-shadow: inset 0 5px white, inset 5px 0 #d7d7d7, inset -5px 0 #bbbb, inset 0 -5px #d7d7d7; } .item { display: block; width: 24px; height: 24px; border-radius: 50%; margin: 4px; background-color: #333; box-shadow: inset 0 3px #111; } .first-face { justify-content: center; align-items: center; } .second-face { justify-content: space-between; } .second-face .item:nth-child(2) { align-self: flex-end; } .third-face { justify-content: space-between; } .third-face .item:nth-child(2) { align-self: center; } .third-face .item:nth-child(3) { align-self: flex-end; } .fourth-face, .fifth-face, .sixth-face { justify-content: space-between; } .fourth-face .column, .fifth-face .column, .sixth-face .column { display: flex; flex-direction: column; justify-content: space-between } .fifth-face .column:nth-child(2) { /* align-self: center; */ justify-content: center; } L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":50,"height":100},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});]]></content>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易项目]]></title>
    <url>%2F2019%2F03%2F06%2F%E7%AE%80%E6%98%93%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[通过复习语法，写的案例 使用的mob的免费接口]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>复习基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理�8位小数数值]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%A4%84%E7%90%86%EF%BF%BD8%E4%BD%8D%E5%B0%8F%E6%95%B0%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在最近的需求中，需要前台来计算展示保留8位小数的数值 在刚开始的时候认为很简单，用了网上的这种方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//除法函数，用来得到精确的除法结果 //说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 //调用：accDiv(arg1,arg2) //返回值：arg1除以arg2的精确结果 function accDiv(arg1,arg2)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; with(Math)&#123; r1=Number(arg1.toString().replace(&quot;.&quot;,&quot;&quot;)) r2=Number(arg2.toString().replace(&quot;.&quot;,&quot;&quot;)) return (r1/r2)*pow(10,t2-t1); &#125; &#125; //给Number类型增加一个div方法，调用起来更加方便。 Number.prototype.div = function (arg)&#123; return accDiv(this, arg); &#125; //乘法函数，用来得到精确的乘法结果 //说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 //调用：accMul(arg1,arg2) //返回值：arg1乘以arg2的精确结果 function accMul(arg1,arg2) &#123; var m=0,s1=arg1.toString(),s2=arg2.toString(); try&#123;m+=s1.split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; return Number(s1.replace(&quot;.&quot;,&quot;&quot;))*Number(s2.replace(&quot;.&quot;,&quot;&quot;))/Math.pow(10,m) &#125; //给Number类型增加一个mul方法，调用起来更加方便。 Number.prototype.mul = function (arg)&#123; return accMul(arg, this); &#125; //加法函数，用来得到精确的加法结果 //说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 //调用：accAdd(arg1,arg2) //返回值：arg1加上arg2的精确结果 function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (arg1*m+arg2*m)/m &#125; //给Number类型增加一个add方法，调用起来更加方便。 Number.prototype.add = function (arg)&#123; return accAdd(arg,this); &#125; //减法函数，用来得到精确的减法结果 //说明：javascript的减法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。 //调用：accSubtr(arg1,arg2) //返回值：arg1减去arg2的精确结果 function accSubtr(arg1,arg2)&#123;var r1,r2,m,n;try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125;try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125;m=Math.pow(10,Math.max(r1,r2));//动态控制精度长度n=(r1&gt;=r2)?r1:r2;return ((arg1*m-arg2*m)/m).toFixed(n);&#125; //给Number类型增加一个subtr 方法，调用起来更加方便。 Number.prototype.subtr = function (arg)&#123; return accSubtr(arg,this); &#125; --------------------- 作者：poker__Face 来源：CSDN 原文：https://blog.csdn.net/u010447573/article/details/50240771?utm_source=copy 版权声明：本文为博主原创文章，转载请附上博文链接！ 不可否认的说这种方法确实解决了的大部分的问题，但是由于我是需要保留8位小数的，因此在为小于8位小数的时候，会出现转换错误的情况 最后发现是toFixed的问题 第一步 接下来就需要处理toFixed方法了 比如：8311696194.60937401.toFixed(8) 的值为 “8311696194.60937405” 第一步解决方案1234567891011121314151617181920212223242526272829&lt;!--通过重写toFixed方法--&gt;&lt;!--toFixed使用的是银行家舍入规则。 银行家舍入:所谓银行家舍入法，其实质是一种四舍六入五取偶（又称四舍六入五留双）法。 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。--&gt; Number.prototype.toFixed = function (d) &#123; var s = this + &quot;&quot;; if (!d) d = 0; if (s.indexOf(&quot;.&quot;) == -1) s += &quot;.&quot;; s += new Array(d + 1).join(&quot;0&quot;); if (new RegExp(&quot;^(-|\\+)?(\\d+(\\.\\d&#123;0,&quot; + (d + 1) + &quot;&#125;)?)\\d*$&quot;).test(s)) &#123; var s = &quot;0&quot; + RegExp.$2, pm = RegExp.$1, a = RegExp.$3.length, b = true; if (a == d + 2) &#123; a = s.match(/\d/g); if (parseInt(a[a.length - 1]) &gt; 4) &#123; for (var i = a.length - 2; i &gt;= 0; i--) &#123; a[i] = parseInt(a[i]) + 1; if (a[i] == 10) &#123; a[i] = 0; b = i != 1; &#125; else break; &#125; &#125; s = a.join(&quot;&quot;).replace(new RegExp(&quot;(\\d+)(\\d&#123;&quot; + d + &quot;&#125;)\\d$&quot;), &quot;$1.$2&quot;); &#125; if (b) s = s.substr(1); return (pm + s).replace(/\.$/, &quot;&quot;); &#125; return this + &quot;&quot;; &#125;; 但这种方式并不可取，因为我在其他地方用到了这个方法 第二种方式自己写一个方法1234567891011121314151617181920212223242526272829303132/** * 重写js Number的toFixed() * @param &#123;Number&#125; d 保留几位小数 * @param &#123;Number&#125; n 要处理的数据 * @returns &#123;string&#125; */function toFixed (d, n) &#123; var s = n + &quot;&quot;; if (!d) d = 0; if (s.indexOf(&quot;.&quot;) == -1) s += &quot;.&quot;; s += new Array(d + 1).join(&quot;0&quot;); if (new RegExp(&quot;^(-|\\+)?(\\d+(\\.\\d&#123;0,&quot; + (d + 1) + &quot;&#125;)?)\\d*$&quot;).test(s)) &#123; var s = &quot;0&quot; + RegExp.$2, pm = RegExp.$1, a = RegExp.$3.length, b = true; if (a == d + 2) &#123; a = s.match(/\d/g); if (parseInt(a[a.length - 1]) &gt; 4) &#123; for (var i = a.length - 2; i &gt;= 0; i--) &#123; a[i] = parseInt(a[i]) + 1; if (a[i] == 10) &#123; a[i] = 0; b = i != 1; &#125; else break; &#125; &#125; s = a.join(&quot;&quot;).replace(new RegExp(&quot;(\\d+)(\\d&#123;&quot; + d + &quot;&#125;)\\d$&quot;), &quot;$1.$2&quot;); &#125; if (b) s = s.substr(1); return (pm + s).replace(/\.$/, &quot;&quot;); &#125; return this + &quot;&quot;;&#125;; 推荐用这个方法来处理，这样可以避免出现错误 第二步 当然通过上面的处理其实已经可以 因此通过这个方式来 补全不够8位数的 当数值超过以后呢会转化成科学计算，要转换成正常的数值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function convertNum(num_str, defaultFill)&#123; //参数必须为字符串 var resValue = &apos;&apos;, // power = &apos;&apos;, // 幂 result = null, // 正则校验结果 dotIndex = 0, // resArr = [], // 值数组 sym = &apos;&apos;; // 正负符号 var numStr = num_str.toString(); //console.log(&apos;numStr[0] = &apos; + numStr[0]); if(numStr[0] == &apos;-&apos;)&#123; // 如果为负数，转成正数处理，先去掉‘-’号，并保存‘-’. numStr = numStr.substr(1); sym = &apos;-&apos;; &#125; // console.log(&quot;numStr = &quot; + numStr) if ((numStr.indexOf(&apos;E&apos;) != -1) ||(numStr.indexOf(&apos;e&apos;) != -1))&#123; var regExp = new RegExp(&apos;^(((\\d+.?\\d+)|(\\d+))[Ee]&#123;1&#125;([+-]?(\\d+)))$&apos;,&apos;ig&apos;); result = regExp.exec(numStr); // console.log(&apos;exp result = &apos; + result); if (result != null)&#123; resValue = result[2]; power = result[5]; result = null; //console.log(&apos;resValue = &apos; + resValue + &quot;, power = &quot; + power); &#125; if (!resValue &amp;&amp; !power)&#123; return num_str; &#125; dotIndex = resValue.indexOf(&apos;.&apos;); resValue = resValue.replace(&apos;.&apos;,&apos;&apos;); resArr = resValue.split(&apos;&apos;); if(Number(power) &gt;= 0)&#123; var subres = resValue.substr(dotIndex); power = Number(power); //console.log(&quot;dotIndex = &quot; + dotIndex + &quot;, power = &quot; + power + &quot;, subres = &quot; + subres); //console.log(&quot;power-subres.length = &quot; + (power-subres.length)); //幂数大于小数点后面的数字位数时,后面加0 for(var i = 0; i &lt; power-subres.length; i++) &#123; resArr.push(&apos;0&apos;); &#125; if(power-subres.length &lt; 0)&#123; resArr.splice(dotIndex+power, 0, &apos;.&apos;); &#125; &#125;else&#123; power = power.replace(&apos;-&apos;,&apos;&apos;); power = Number(power); var zeroSize = 0; if(dotIndex &gt; -1)&#123; zeroSize = power-dotIndex+1; &#125;else&#123; zeroSize = power; &#125; //幂数大于等于小数点的index位置,前面加0 for(var i = 1; i &lt;= zeroSize; i++) &#123; resArr.unshift(&apos;0&apos;); &#125; var n = power-dotIndex &gt;= 0 ? 1 : -(power-dotIndex); resArr.splice(n, 0, &apos;.&apos;); &#125; &#125;else&#123; resArr = num_str.split(&apos;&apos;); &#125; //console.log(&quot;resArr = &quot; + resArr); resValue = resArr.join(&apos;&apos;); var resultStr = sym + resValue; //console.log(&quot;result = &quot; + resultStr); var bit = defaultFill ? 8 : 2; //console.log(&quot;defaultFill = &quot; + defaultFill + &quot;, bit = &quot; + bit); // 补全8位小数 var index = resultStr.indexOf(&apos;.&apos;); if(bit &gt; 0)&#123; if(index &gt; -1)&#123; var str = resultStr.substr(index+1); //console.log(&quot;str = &quot; + str); for(var i = 0; i &lt; bit - str.length; i++)&#123; resultStr+=&apos;0&apos;; &#125; &#125;else&#123; resultStr+=&apos;.&apos;; for(var i = 0; i &lt; bit; i++)&#123; resultStr+=&apos;0&apos;; &#125; &#125; &#125; return resultStr;&#125; 第三步 因此就将上面网上找的加减乘除方法舍去引用了插件 npm install number-precision –save 网站地址 https://github.com/nefe/number-precision 通过这个插件的方法处理数据,将科学计数的转换成普通得 第四步 用上面的方法其实已经可以将8位或者小于8位的小数，正常显示了 当大于8位小数的则不行，会超出去 因此需要截取处里（根据需求，在8位数后有值就在第8位加1） 123456789101112numFixed(num) &#123; let left = num.split(&apos;.&apos;)[0] let right = num.split(&apos;.&apos;)[1].slice(0, 8) let nine = num.split(&apos;.&apos;)[1].slice(8, 16) let res = left + &apos;.&apos; + right; // 如果nine的值是大于1的就必须在第八位加+ if(Number(nine) &gt; 0)&#123; res = NP.plus(Number(res), 0.00000001); &#125; return res; &#125;, 最后通过判断12345678910 &lt;!-- 获取当前的值小数点后有多少位--&gt; var n = convertNum(total.toString(),false); var l = n.toString().split(&quot;.&quot;)[1].length;&lt;!--通过判断长度，确定执行的代码--&gt; if( l &gt; 8 )&#123; this.costTotals = RewritetoFixed(8,convertNum(total.toString(),false)); &#125;else&#123; this.costTotals = convertNum(total.toString(),true); &#125; 结束 当前没有遇到错误 如果前台处理这种数据，最好能处理下toFixed方法，毕竟超出一定位数，精确度就会不够 最后执行的结果不排除有数值会精确不到]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序中遇到的一些问题]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近学习小程序踩的坑小程序的上拉和下拉刷新 上拉加载需要在json文件中开启 1&quot;enablePullDownRefresh&quot;: true 在请求结束以后页面并不会立刻回弹，因此需要我们： 1wx.stopPullDownRefresh() // 停止当前刷新 下拉加载中的问题 在设置api地址时，设置冲突，导致api变量累加，而不时pagesize累加 需要注意的是： 在我们通过app.json中添加页面的时候，当前的js中会配置相关的操作方法，如果再次写下拉或者上拉方法，在此时就是失效的，需要写在规定的方法中]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名绑定到github以及coding上]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E5%88%B0github%E4%BB%A5%E5%8F%8Acoding%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[前言 由于腾讯云活动买了个云主机，因此最近一直在等待备案完成，将域名绑定到github和coding中 因为是第一次接触走了很多弯路，后来发现文档挺详细的就按照https://cloud.tencent.com/document/product/213/8044 地址搭建了wordpress博客 由于没有wordpress的经验，就想到用hexo的主题博客，因为之前已经搭建成功了github.io,和coding的主页，因此直接拿来用 域名解析 首先找到所注册的域名地址，解析 当然同样可以设置ip的还可以选择线路来区分访问的是那个网址 绑定网址 当我们解析成功以后，就应该把地址绑定到之前的博客地址上 Coding官网可以用github来登录 找到当前项目目录下的pages服务 接下来是绑定github项目，在该项目中点击settting按钮进入 当绑定以后可以进行访问，如果还是404就查看是否解析错误，绑定的域名是否正确注意 在github时绑定的域名偶尔会失效，访问404，后来发现需要在hexo的source下新建一个文件CNAME没有后缀 在当前文件内填写域名 执行命令 12hexo ghexo d 绑定coding博客 在新建博客的时候注意ssh的到期日期，否则有可能hexo执行的时候，coding上传不了文件 绑定畅言评论（必须备案过） 创建畅言号码，一步一步走下去 hexo在主题的配置文件下设置(themes\next下的_config.yml) 12345# changyanchangyan: enable: true appid: xxxxxxx // 根据畅言后台设置 appkey: xxxxxxxx // 根据畅言后台设置 查看后台总览的 如果要使用其他评论可以查看这个地址的介绍https://blog.csdn.net/qq_32454537/article/details/79482879]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初步使用nuxt]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8nuxt%2F</url>
    <content type="text"><![CDATA[travel-mk-nuxt 初步了解使用nuxt.js渲染仿去哪的三个页面 nuxt的具体使用步骤，以及了解参考[官网](https://zh.nuxtjs.org/guide) 本项目并不复杂，因此只使用了nuxt的一些基本功能（移动端并不推荐）第一步安装nuxt.js (参考技术胖)123vue init nuxt/starternpm installnpm run dev 需要注意：如果不是新建项目，最好另开一个文件夹，我就在直接覆盖了，幸好留有旧文件 安装完成以后，就开始将文件移入 首先将首页引入 将index.vue放置在pages目录下，其中用到的组件放置在components下 运行以后会报错，找不到css，则将所用到的css全部引入 公用css应该在nuxt.congig.js中使用123456css:[ &apos;~assets/styles/reset.css&apos;, &apos;~assets/styles/border.css&apos;, &apos;~static/iconfont/iconfont.css&apos;, &apos;swiper/dist/css/swiper.css&apos; ], 接下来吧store引入 接下来就会提示swiper is undefind,此时经过查询官网，发现引入方式错误，应该重新引入1234567891011121314&lt;!-- 第一步安装vue-awesome-swiper --&gt;npm install vue-awesome-swiper -S&lt;!-- 第二步在plugins下新建目录表示使用 --&gt;&lt;!-- 目录名 vue-awesome-swiper.js --&gt;import Vue from &apos;vue&apos;import VueAwesomeSwiper from &apos;vue-awesome-swiper/dist/ssr&apos;Vue.use(VueAwesomeSwiper)&lt;!-- 在nuxt.config.js中使用 （(第三方插件都应该在这里)）--&gt;plugins: [ &#123; src: &apos;~/plugins/vue-awesome-swiper.js&apos;, ssr: false &#125;,], 其他错误提示： 当我们将组件放置在pages文件夹下回提示 found in ，找不到文件，因此需要放置在components文件夹下 当完成以上内容以后，会报错localStorage is undefind;因此删除在这里的localStorag 在index的mounted中判断localStorage是否保存了变量来更改 （因为node端是没有window的无法实现，只有浏览器渲染以后才能够实现） 当将store复制过来，会提示store is undefind，这是因为没有导出变量，需要更改成12const store = () =&gt; new Vuex.Store(&#123;&#125;)export default store 当把首页处理好以后，剩下两个页面就可以不用更改直接使用了 需要注意的是在这个模式下使用better-scroll，会出现click在手机模式下失效，因此需要修改为1this.scroll = new BScroll(this.$refs.wrapper,&#123; mouseWheel: true, click: true, tap: true &#125;) 最后需要 放置重复打包 , node的版本必须大于8 否则会提示 错误1vendor: [&apos;vuex&apos;,&apos;axios&apos;], 2018.8.9 更新1.发现字母表无法点击 没有找到click失效的原因，因此就在touchstart中重复了一遍click事件 2.详情页面头部动画失效 因为之前是写在activated和deactivated中的，window是获取不到的，需要写在mounted中 deactivated需要替换成destroyed生命周期来销毁全局事件 3.每次返回首页都刷新页面 - 能力不足不知道怎么改，暂时放置 4.打包以后路径不匹配的两种解决方式123456789&lt;!-- 第一种 在nuxt.config.js的build--&gt;if(!isDev)&#123; config.output.publicPath = &apos;./_nuxt/&apos;;&#125;&lt;!-- 第二种 在nuxt.config.js的build --&gt;build: &#123; // 这里是你要访问的实际地址 publicPath: &apos;xxxx&apos;,&#125;, 综合来说第二种更好，第一种有bug。比如你有多级路由parent/child和parent两个路由，这样会导致你一个页面访问parent/child/_nuxt/main.js和parent/_nuxt/main.js，明显冲突了（参考地址）]]></content>
      <categories>
        <category>vue</category>
        <category>nuxt</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue仿去哪的首页城市页以及详情页]]></title>
    <url>%2F2018%2F08%2F10%2Fvue%E4%BB%BF%E5%8E%BB%E5%93%AA%E7%9A%84%E9%A6%96%E9%A1%B5%E5%9F%8E%E5%B8%82%E9%A1%B5%E4%BB%A5%E5%8F%8A%E8%AF%A6%E6%83%85%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[travel-mk 仿去哪网的三个页面 用到的框架 vue + vuex + vue-router + axios + better-scroll + vue-awesome-swiper 实现步骤第一步 安装vue-cli npm install -g vue-cli 通过脚手架安装好模版 vue init webpack travel-mk 根据提示完成 每次新建好主页面，都需要在router中配置相关路由注意事项： 可以通过vue -V判断是否有vue-cli的存在 第二步 - 完成首页 我们需要一些图标，可以通过iconfont引入 http://www.iconfont.cn/(具体使用方式参考https://blog.csdn.net/wh2691259/article/details/52233140) css的预处理器使用scss了12npm install --save-dev sass-loadernpm install --save-dev node-sass 安装完成以后就可以使用scss了 首页banner的实现 使用了vue-awesome-swiper框架 使用方式查看 https://www.npmjs.com/package/vue-awesome-swiper 详细使用方式查看https://www.swiper.com.cn/api/index.html 在项目中使用的是按需引入，操作如下123456789101112131415161718&lt;!-- 在script中引入 --&gt;import &#123; swiper, swiperSlide &#125; from &apos;vue-awesome-swiper&apos;import &apos;swiper/dist/css/swiper.css&apos;&lt;!-- 组件使用 --&gt;components: &#123; swiper, swiperSlide&#125;,&lt;!-- 在data中定义好数据，然后在template中使用 --&gt;&lt;swiper :options=&quot;swiperOption&quot; class=&quot;wrapper&quot;&gt; &lt;swiper-slide v-for=&quot;slide in swiperSlides&quot; :key=&quot;slide.id&quot;&gt; &lt;img :src=&quot;slide.imgUrl&quot; :alt=&quot;slide.title&quot;&gt; &lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;&lt;/swiper&gt;&lt;!-- data中设置 --&gt;&lt;!-- swiperOption的变量，具体可看官网(https://www.swiper.com.cn/api/index.html) --&gt;&lt;!-- 注意:3.0.0以上查看4.0的api，低于3.0.0查看3.0的api --&gt; 菜单页面的完成 先按照一般布局进行布局，完成以后发现可以翻页，因此使用了swiper插件进行包装 同上轮播图一样12345678910111213141516171819&lt;!-- 这是菜单布局 --&gt;&lt;div class=&quot;icon&quot; v-for=&quot;item in page&quot; :key=&quot;item.id&quot;&gt; &lt;a class=&quot;imgbox&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; :alt=&quot;item.desc&quot;&gt; &lt;/a&gt; &lt;span&gt;&#123;&#123;item.desc&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;!-- 这是使用swiper以后 --&gt;&lt;swiper :options=&quot;swiperOption&quot;&gt; &lt;swiper-slide v-for=&quot;(page,index) in pages&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;icon&quot; v-for=&quot;item in page&quot; :key=&quot;item.id&quot;&gt; &lt;a class=&quot;imgbox&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; :alt=&quot;item.desc&quot;&gt; &lt;/a&gt; &lt;span&gt;&#123;&#123;item.desc&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;&lt;/swiper&gt; 因为api返回的数据是不符合要求的，因此需要处理成我所需要的格式 1234567891011121314&lt;!-- 如果不处理。会渲染多个swiper不止两个 --&gt;&lt;!-- 在计算属性中计算 --&gt;computed()&#123; const page = []; this.List.forEach((v,index)=&gt;&#123; const page = Math.floor(index/8) // 一屏要暂时8个，因此下标下应该有8条数据 if (!pages[page]) &#123; // 不存在就为空 pages[page] = [] &#125; pages[page].push(item) &#125;) return pages&#125; 接下来就是热门榜单，猜你喜欢以及周末去哪模块 布局就不说了，使用flex布局会更方便 第三步 完成城市列表页面1.需要点击首页的城市跳转到列表页，因此12345&lt;!-- 设置router-like跳转 --&gt;&lt;router-link to=&quot;/city&quot;&gt; &lt;span&gt;&#123;&#123;city&#125;&#125;&lt;/span&gt; &lt;i class=&quot;iconfont icon-sanjiao&quot;&gt;&lt;/i&gt;&lt;/router-link&gt; 建立city.vue文件，搜索组件，列表组件以及字母表组件（具体查看） 3.在建立List组件时使用了better-scroll插件(地址)123456789101112131415161718&lt;!-- 在项目中的使用方式 --&gt;import BScroll from &apos;better-scroll&apos;import &#123;mapState, mapMutations&#125; from &apos;vuex&apos;&lt;!-- 使用 --&gt;mounted () &#123; this.$nextTick(() =&gt; &#123; this.scroll = new BScroll(this.$refs.wrapper) &#125;)&#125;,&lt;!-- template中使用 --&gt;&lt;div class=&quot;wrapper&quot; ref=&quot;wrapper&quot;&gt; &lt;ul class=&quot;content&quot;&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- 这里可以放一些其它的 DOM，但不会影响滚动 --&gt;&lt;/div&gt; 需要注意的标签的格式，否则是无法使用的, 如果使用插件以后的click事件等无法使用，需要使用下面的方式 1this.scroll = new BScroll(this.$refs.wrapper,&#123; mouseWheel: true, click: true, tap: true &#125;) 最后需要注意的是如果完成以上插件还是不生效，请设置最外层div的定位 12345678910&lt;!-- 例如： --&gt;.list&#123; background: #f5f5f5; overflow: hidden; position: absolute; top: 1.58rem; left: 0; right: 0; bottom: 0; &#125; 完成字母表的封装(通过taouch事件实现) 跳转指定字母下通过插件的scrollToElement方法 123456letter () &#123; if (this.letter) &#123; let ele = this.$refs[this.letter][0] this.scroll.scrollToElement(ele) &#125;&#125; 完成以上数据，就该实现点击城市，返回主页面，更改城市 当城市发生改变是使用了vuex，保存了一个state的值city通修改city同步改变 123456789101112handlechangeCity (val) &#123; // 第一种方式:通过修改actions的值，来同步修改 // this.$store.dispatch(&apos;changeCity&apos;, val) // 第二种，直接修改mutations // this.$store.commit(&apos;changeCity&apos;, val) // 第三种方式 this.changeCity(val) this.$router.push(&apos;/&apos;) // 保存到本地 localStorage.setItem(&apos;city&apos;, val) &#125;, ...mapMutations([&apos;changeCity&apos;]) 因为刷新以后不存在了，所以需要保存在本地 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- vuex中写 --&gt;import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)let defaultCity = &apos;北京&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125; catch (err) &#123; console.log(err)&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity &#125;, actions: &#123; changeCity (ctx, city) &#123; ctx.commit(&apos;changeCity&apos;, city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city try &#123; if (localStorage.city) &#123; localStorage.city = city &#125; &#125; catch (err) &#123; console.log(err) &#125; &#125; &#125;&#125;) 第四步 详情页面 详情页面难点主要在与图片的展示以及滚动时heade的颜色变化 head的颜色变化1234567891011121314151617181920212223242526&lt;!-- 因为使用了keepalive，因此时间写在actived里 --&gt;activated () &#123; window.addEventListener(&apos;scroll&apos;, this.handleScroll)&#125;,&lt;!-- 在离开当前组件是移除，防止其他页面也会触发该事件 --&gt;deactivated () &#123; window.removeEventListener(&apos;scroll&apos;, this.handleScroll) this.isbgColor = true&#125;,&lt;!-- 在事件中判断滚动的高度来改变状态 --&gt;handleScroll () &#123; const top = document.documentElement.scrollTop || document.body.scrollTop // console.log(top) if (top &gt; 5) &#123; this.isbgColor = false let opacity = top / 140 opacity = opacity &gt; 1 ? 1 : opacity this.opacity = &#123;opacity&#125; this.opacityIcon = &#123;opacity&#125; &#125; else &#123; this.isbgColor = true this.opacityIcon = &#123; opacity: 1 &#125; &#125; &#125;, 图片的展示 同样使用了swiper组件12345&lt;!-- 配置就不细说，重点是在使用时的注意事项 --&gt;&lt;!-- 由于使用了fixed的布局，因此需要在swiper-wrapper上添加align-items:center;才能居中 --&gt;.swiper-wrapper&#123; align-items:center; &#125; 到现在就算完成了这几个页面。在页面中还有一些注意事项 不要把mock数据放在src里，应该放在static，否则会找不到地址 在使用nuxt.js的时候，需要更改swiper的引用 如果是个人项目，api在proxyTable中写了，最好在打包以后，不要用，用api给定的，因为我们没有使用ng去转发，是不能找到地址的]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端特效链接]]></title>
    <url>%2F2018%2F06%2F25%2F%E5%89%8D%E7%AB%AF%E7%89%B9%E6%95%88%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[转载至 木子的博客 前端最全框架转载至qq_36538012的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流的实现]]></title>
    <url>%2F2018%2F06%2F19%2F%E7%80%91%E5%B8%83%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[瀑布流实现瀑布流即不规则的布局实现代码html和css可以访问地址 该布局时通过等宽来实现的瀑布流 并没有完美实现代码，在滚动加载会出现图片重叠现象(已经修复– 通过判断图片是否加载成功给定高度) 使用的jquery代码完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104$(function()&#123; // 获取要操作的dom元素 var domObj = &#123; wrap: $(&apos;.wrap&apos;), boxs: $(&apos;.wrap div&apos;) &#125; waterFull(domObj) // 接下来需要实现滚动加载 $(this).scroll(function()&#123; appendBox(domObj) &#125;)&#125;)// 定义瀑布流function waterFull(value)&#123; // 先获取单个的宽度 var boxW = value.boxs.eq(0).outerWidth(true); // 获取当前屏幕的宽度 var winW = $(window).width(); // 判断当前屏幕可以放置多少个元素 var cols = Math.floor(winW/boxW); // 设置当前包裹元素的宽度 value.wrap.css(&#123;width: cols*boxW + &apos;px&apos;&#125;) // 接下来需要设置div的布局 var arrayW = new Array() for( var i = 0; i &lt; value.boxs.length; i++ )&#123; // 等第一行的时候将元素的高度保存在数组 if( i &lt; cols )&#123; arrayW[i] = value.boxs.eq(i).outerHeight(true); &#125;else&#123; // 取出最小高度 var minH = Math.min.apply(null,arrayW); // 获取当前的下标，为了计算left的偏移值 var index = getIndex(minH,arrayW); // 偏移量 var leftW = index*boxW + &apos;px&apos;; // 设置样式 setStyle(value,minH,leftW,i) // 当执行完一个，就更新数组，重新计算数组的最小高度 arrayW[index] += value.boxs.eq(i).outerHeight(true); &#125; &#125;&#125;// 下标获取function getIndex(minH,arrayW)&#123; for( index in arrayW )&#123; if( arrayW[index] == minH )&#123; return index; &#125; &#125;&#125;// 设置样式var num = 0function setStyle(value,minH,leftW,index)&#123; if( num &gt;= index )&#123; return &#125; value.boxs.eq(index).css( &#123;position:&quot;absolute&quot;, top: minH + &apos;px&apos;, left:leftW&#125; ).stop().hide().fadeIn() num = index&#125;// 滚动事件function appendBox( domObj )&#123; // 首先需要遍历获取的data元素 // 将他们放入定义好的字符串 // 将内容追加到wrap中 // 重新执行瀑布流函数 var str = &apos;&apos;; if(getChecked(domObj.wrap))&#123; for( var i = 0; i &lt; data.length; i++)&#123; str += &apos; &lt;div&gt;&lt;img src=&quot;&apos;+data[i].imgUrl+&apos;&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&apos; &#125; domObj.wrap.append(str) domObj.boxs = domObj.wrap.children(&apos;div&apos;) // 因为是后来追加进去的，所以并没有添加上属性 waterFull(domObj) &#125;&#125;// 判断是否到了底部在加载function getChecked(wrap)&#123; // 获取视图的高度 + 滚动条的高度。就是当前所移动的高度 var viewW = $(window).outerHeight(true); var scrollW = $(window).scrollTop(); var WWidth = viewW + scrollW + 200 // 获取最后一个盒子的距离顶部的高度 + 自身的高度 // 获取最后一个盒子的总高度 var boxs = wrap.children(&apos;div&apos;) var boxW = boxs.eq(boxs.length-1).outerWidth(true); var offsetTop = boxs.eq(boxs.length-1).offset().top; var Wbox = boxW + offsetTop;console.log( WWidth , Wbox) return WWidth &gt;= Wbox ? true:false&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端资源链接地址]]></title>
    <url>%2F2018%2F06%2F06%2F%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[HTML HTML5开发 链接：https://pan.baidu.com/s/1Pq9QGmIDOSZIr2U1o6YKNQ 密码：75ev 玩转HTML5移动端APP混合应用开发实战 链接：https://pan.baidu.com/s/1yK5I63Froc59cbolfP7rwg 密码：4y8b HTMl5与CSS3实现动态网页 链接：https://pan.baidu.com/s/1TgUHkrlXhS1wwlxpUHTC-w 密码：lqdu h5实战开发 链接：https://pan.baidu.com/s/1NfLrF0rvj5B5nr4DMi4WAA 密码：43yg css css3 3d 特效 链接：https://pan.baidu.com/s/1UStK1F66Je7QGttTuG-6eA 密码：verj CSS3视频教程 链接：https://pan.baidu.com/s/1Rfv9R0qzdow0J_hiAYjoVQ 密码：z409 CSS3实战 链接：https://pan.baidu.com/s/19A8G2uWjA_UEFBstCgXn2A 密码：n5qb js 妙味js学习 链接：https://pan.baidu.com/s/1J0TqKpmWppTjbyvw2LO_9Q 密码：74qi mock.js-无需等待，让前端独立于后端进行开发–NodeJS搭建服务端调试接口实战京东商城数据模拟 链接：https://pan.baidu.com/s/1-YgJMgbDh_L0OLaA-RBeGA 密码：o6wt 黑马 javascript基础加强版 链接：https://pan.baidu.com/s/1fSmvVB3gidoH4_fJbiuUWA 密码：qnd6 vue 某课网 vue2.5开发去哪网 链接：https://pan.baidu.com/s/1oIcVl9Gr3fAMizKa7RyNMA 密码：d0rv 某课网 vue核心技术 链接：https://pan.baidu.com/s/1_TnYmkRA7ry7JjjD3HTgXQ 密码：or4s 某课网 开发微信全家桶项目Vue/Node/MongoDB高级技术栈全覆盖 链接：https://pan.baidu.com/s/1ETlotIlmaFQqWn-GldH8qw 密码：6621 Vue2.0 实战电商 链接：https://pan.baidu.com/s/13jtNXNuvBb9c0_DaA5pHiw 密码：e2bm vue2.0快速入门 链接：https://pan.baidu.com/s/1DO0KqV4qdzl2nhX-XXkRlQ 密码：mghs vue2.0实战新闻客户端 链接：https://pan.baidu.com/s/1_2GxRiIrsDhwiaX0U2Dvmw 密码：z3yz 前端福音，vue.js 之豆瓣电影组件大揭秘-video 链接：https://pan.baidu.com/s/1yHJn8Jo0BLsmfK04pE4_9g 密码：y0hm 带你入门Vue2.0及案例开发 链接：https://pan.baidu.com/s/1xXUXhEYpWFiiEzPd7W9gCA 密码：ycly 慕课网 Vue 2.0 移动端音乐App【完整版】 链接：https://pan.baidu.com/s/1SAJ7A3DfD74zul1kPejbiA 密码：d7bo vue2.0+node.js+MongoDB全栈打造商城（完整版） 链接：https://pan.baidu.com/s/1cmkpvZvGKHTvzk37YsMaNQ 密码：k7tg 慕课网 Vue 2.0 移动端音乐App【完整版】 链接：https://pan.baidu.com/s/1SAJ7A3DfD74zul1kPejbiA 密码：d7bo 微信小程序 微信小程序学习 链接：https://pan.baidu.com/s/1fGmAAhUgFyhL9TGKwDP3jA 密码：gpj5 极客微信小程序 链接：https://pan.baidu.com/s/1GIPod73ta7xvcNqbKZWAeQ 密码：djln 小程序 慕课网 链接：https://pan.baidu.com/s/1kXjeFRAHOAVUgy6TcRlZ6w 密码：oemf 微信小游戏入门与实战 刷爆朋友圈 链接：https://pan.baidu.com/s/1WzSPFnWw-upu3aAH7op5Ug 密码：whck React 2017最新彻底征服React Native基础 链接：https://pan.baidu.com/s/15A0fYrm78z3bv17eitDqcw 密码：1jju React Native零基础入门到项目实战 链接：https://pan.baidu.com/s/1IAXTELBpPcwseCPnmTEjAQ 密码：8mr2 react快速开发教程 链接：https://pan.baidu.com/s/1ZoX0WCvW9tpnE_CvWienTw 密码：wubd 珠峰React系列视频 链接：https://pan.baidu.com/s/1Sp_9Scgc-QaMvPyICqyzGw 密码：qcu5 React Native基础视频 链接：https://pan.baidu.com/s/13ZT8jFT-IMgAiUZzS-hQ3A 密码：3s3n react必备辅助知识 链接：https://pan.baidu.com/s/1VEEtCi8OPHVmgyCITdFl4w 密码：mlxn React Native 综合知识实战项目 链接：https://pan.baidu.com/s/1FJHblUh99Ehmn4ooFTn-KQ 密码：2x68 React Native学习 链接：https://pan.baidu.com/s/1bP24ikl4vH27jZwG50VrDg 密码：dti8 React Native电商实战视频教程 链接：https://pan.baidu.com/s/116bBb11EVPhEdVOZ6ES8-w 密码：gtmj React Native基础知识 链接：https://pan.baidu.com/s/1Y5ZrsQ069eg5bs4mNP6s2Q 密码：nhs5 React Native进阶 链接：https://pan.baidu.com/s/1TREqSOSWXgU43puF0GnhVw 密码：van2 贯穿全栈React Native开发App 链接：https://pan.baidu.com/s/1Euoc3dU_skGONnlV1ToJiA 密码：7wm5 React Native开发App狗狗说 链接：https://pan.baidu.com/s/1swoCOZFD1e6UjelE59FIng 密码：xrjy Redux+React Router+Node.js全栈开发 链接：https://pan.baidu.com/s/1SLcvcoVQkE6ys1dOpg6TVw 密码：tvwj 面试技巧 2.5k前端面试大神手把手教 链接：https://pan.baidu.com/s/1KQeRagCDprw7GTconVhbLQ 密码：5slr 前端JS基础面试技巧 链接：https://pan.baidu.com/s/1u3EmvgI8mgp9gAR1Ez905Q 密码：ke9b 前端电子书 前端电子书 链接：https://pan.baidu.com/s/1KdtPtCXpxAkFgZzd5Dg9mw 密码：am2t UI学习 传智UI40期 链接：https://pan.baidu.com/s/197Fw5MXMoUhNRd-XkDcaqw 密码：0gnz 技术胖免费视频分享 链接：https://pan.baidu.com/s/1Oot-P4mMqE74iuseXBhigg 密码：1s65 PS初级教程前30节 链接：https://pan.baidu.com/s/1B-zsiWpdfg2KG6jNX2tzHg 密码：s9uv PS公开课 链接：https://pan.baidu.com/s/18EukiNjftvosWExFvbcoNA 密码：o3hc 其他教程 妙味电子商务网站实战 链接：https://pan.baidu.com/s/1R7hj-Y9Yjx8fnXNrIuxp2w 密码：2tug web前端高级全栈工程师高薪特训英班开完整版（价值381元） 链接：https://pan.baidu.com/s/1iCauh_2_0I-iCTCh9R5MAg 密码：yd91 爱创课堂web前端培训视频 链接：https://pan.baidu.com/s/1pODWI9OpxVsiwggIgVx3AA 密码：9z6i 2017最新移动端交互开发入门到精通 链接：https://pan.baidu.com/s/1H8cGPuUFoiS6im77evfGRw 密码：c2r6 前端开发必备jQuery实用插件讲解 链接：https://pan.baidu.com/s/1M4fLedxcYZuMD9SjWBsh1A 密码：io3h 2017最新移动端实战易企秀视频教程 链接：https://pan.baidu.com/s/1rmfG962W25ONVJBYk027Mg 密码：qvfq 玩转git与github 链接：https://pan.baidu.com/s/11JDMYa0InhNP6cIZEgXqKA 密码：agxj 响应式开发一招致胜 链接：https://pan.baidu.com/s/17s89vr1qZi0ywjyeMDUkyg 密码：6n39 ES6高级入门实战 链接：https://pan.baidu.com/s/1G0oO2okCZjOtOSUnH1vFbQ 密码：611v 2016移动端 链接：https://pan.baidu.com/s/1gJtT8-kB0kfDU488FynTlA 密码：q1a0 webpack +less +es6 环境的搭建 链接：https://pan.baidu.com/s/1BqdDG_858rAMdB8dGmI7Kw 密码：sxcz 小凡老师五天项目实战-美团网 链接：https://pan.baidu.com/s/15BxVNGWe5l8Vh880faLXdg 密码：r68s 达内最新视频 链接：https://pan.baidu.com/s/1MRHIN7GQZDt0ktl1WSb0sw 密码：iltt 达內-前端 链接：https://pan.baidu.com/s/1vcUesg9o6M6BKtPYKkYcJA 密码：if0e 瀑布流布局 链接：https://pan.baidu.com/s/1nAWUyJRrwJSnd8BqTp3qww 密码：7ahz NodeJS精英班视频 链接：https://pan.baidu.com/s/1Zintkwni82hQpK64Rsdv4g 密码：xai4 jquery动画以及,ajax基础知识 链接：https://pan.baidu.com/s/1QtHvJArpFL5W53tpEBQiTQ 密码：577n webpack公开课 链接：https://pan.baidu.com/s/1zJmyWMzqSiFW4O1Oetf1LA 密码：55yu 美团网开发（基于HDPHP） 链接：https://pan.baidu.com/s/1B7AUbN6YCG7riQpBoRaIfw 密码：f6et WEB前端入门到精通 链接：https://pan.baidu.com/s/1-s3RKvMeJze6CXRh0_WQfQ 密码：htv7 2016北京传智PHP培训42期 基础+就业 链接：https://pan.baidu.com/s/1ki4kamRIVnZoYG--mePpyw 密码：5nfj 前端基础 链接：https://pan.baidu.com/s/1kGjaORAbHLCIbtWIMsBIDQ 密码：tvrh nodejs入门到精通（基础+就业）全套 链接：https://pan.baidu.com/s/1JTHO8ugAPgCAwFznIjbWbw 密码：fi0b 所向披靡的响应式开发 链接：https://pan.baidu.com/s/1sXy0u7SAzuCQw5pqwHMgzw 密码：463e 打造扛得住的MySQL数据库架构 链接：https://pan.baidu.com/s/1QjE7N6FLfDnfy3Fz9cGMTQ 密码：vsai 6小时jQuery开发小应用 链接：https://pan.baidu.com/s/1uwBS3-W9tBPJ3i8jyu82rw 密码：ctkd 7天搞定Node.js微信公众号开发 链接：https://pan.baidu.com/s/10zQeb1gR7EqzRXIBE5s-8Q 密码：xort Nodejs 项目的线上服务器部署与发布 链接：https://pan.baidu.com/s/1tnL-qdO0eNmwF9a2B_lJZg 密码：vr94 Node.js入门到企业Web开发中的应用 链接：https://pan.baidu.com/s/1oowOHxjIcaJLBpOJ2XzMLg 密码：i1id 企业级刚需Nginx入门，全面掌握Nginx配置+快速搭建高可用架构 链接：https://pan.baidu.com/s/1f187FXUr82EwePiTyT8mIA 密码：uxqq 前端小白入门系列课程 链接：https://pan.baidu.com/s/1MJL658snKnaLytMaS7bLCA 密码：h80e]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node爬虫爬取豆瓣电影]]></title>
    <url>%2F2018%2F06%2F05%2Fnode%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[爬虫爬去豆瓣电影 安装node （网上教程就不写了） 创建一个文件夹 &gt; app.js 执行 npm init 初始化完成，需要安装爬虫需要的插件 1npm i -S puppeteer 在app.js中引入代码定义要爬去的地址 12const puppeteer = require(&apos;puppeteer)const url = &apos;https://movie.douban.com/explore#!type=movie&amp;tag=%E5%96%9C%E5%89%A7&amp;sort=rank&amp;page_limit=20&amp;page_start=0&apos; 套用puppeteer的方法先打开地址 123456const brower = await puppeteer.launch();const page = await brower.newPage(); // 打开一个新地址await page.goto(url,&#123; waitUntil: &apos;networkidle2&apos; // 等待网络状态为空闲的时候才继续执行&#125;) ok，地址打开了，就需要等待按钮出现了12345await page.waitForSelector(&apos;a.more&apos;) // 拿到点击加载更多这个按钮&lt;!-- 点击加载数据（这里拿到两页的数据） --&gt;for(var i = 0;i&lt; 10;i++)&#123; await page.click(&apos;a.more&apos;) //点击这个按钮&#125; 最后就该处理这些数据的结构1234567const = await page.evaluate( ()=&gt; &#123; &lt;!-- 拿到当前页面的jquery（也可以不拿） --&gt; let $ = window.$ &lt;!-- 拿到图片列表 --&gt; let items = $(&apos;.list a&apos;) var links = []&#125;) 拿到了dom数组，但并不能直接使用forEach,因此12345&lt;!-- 第一种方式 --&gt;items = Array.prototype.map.call(items,item=&gt;item)&lt;!-- 第二种 使用es6语法 --&gt;items = Array.from(items) 经过处理，就可以使用foreach方法了123456789101112131415161718192021if( items.forEach &gt;=1 )&#123; items.forEach( item =&gt; &#123; let item = $(item) // 因为使用的jquery语法，因此需要先转成jquery // 获取id let id = it.find(&apos;div&apos;).data(&apos;id&apos;) // 获取标题 let title = it.find(&apos;p&apos;).prop(&apos;firstChild&apos;).nodeValue.trim() //获取评分 let score = it.find(&apos;strong&apos;).text().trim() // 获取图片地址 let imgUrl = it.find(&apos;img&apos;).attr(&apos;src&apos;)huo links.push(&#123; id, title, score, imgUrl &#125;) &#125;) return links;&#125; 最后打印出来12console.log(result)await browser.close(); 将拿到的数据保存到本地文件123456789101112131415161718192021222324252627&lt;!-- 新建一个文件夹config&gt; default.js --&gt;const path = require(&apos;path&apos;)module.exports = &#123; result: path.resolve(__dirname,&apos;../result&apos;), data: path.resolve(__dirname,&apos;../data&apos;)&#125;&lt;!-- 在app.js中引入 --&gt;const &#123; data &#125; = require(&apos;./config/default&apos;)&lt;!-- 在在当前文件下建立一个saveUrl.js,处理文件保存地址 --&gt;const http = require(&apos;http&apos;)const https = require(&apos;https&apos;)const fs = require(&apos;fs&apos;)const path = require(&apos;path&apos;)const &#123; promisify&#125; = require(&apos;util&apos;)module.exports =async(json,dir) =&gt; &#123; try&#123; const file = path.join(dir,`$&#123;Date.now()&#125;.json`) console.log(`设置保存的地址 $&#123;file&#125;`) var jsonString = JSON.stringify(json) await fs.writeFile(file,jsonString) &#125;catch(ex)&#123; console.log(&apos;无法描述的错误&apos;) &#125;&#125; 最后同样在app.js中导入，使用12const saveUrl = require(&apos;./config/saveUrl&apos;) await saveUrl(result,data) 上面是手动创建，如果要自动创建文件夹，就修改saveUrl.js文件123456789101112&lt;!-- 首先判断是否存在，不存在就创建,其他的一样 --&gt;await fs.access(&apos;flie&apos;,(err,status)=&gt;&#123;&apos; if(err)&#123; console.log(&apos;不存在&apos;) &lt;!-- 创建 --&gt; fs.mkdir(&apos;datas&apos;,err =&gt;&#123; if(err)console.log(err) console.log(&apos;创建成功&apos;) &#125;) &#125; fs.writeFile(file,jsonString)&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载和预加载链接]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[懒加载参考地址 预加载预加载是指在页面加载完成之前，提前将所需资源下载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;img class=&quot;backImg&quot; src=&quot;&quot; alt=&quot;图片&quot;&gt; &lt;script&gt; window.onload = function ()&#123; var imgWrap = document.getElementsByClassName(&apos;backImg&apos;); var urls = [ &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p579729551.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2315672647.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p510861873.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2503997609.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2455050536.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1454261925.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p663036666.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1280323646.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2364094053.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p792443418.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2522331945.jpg&apos;, &apos;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2189265085.jpg&apos;, ] function preloadImg( url)&#123; for(let i = 0;i&lt; url.length;i++)&#123; imgWrap[i] = new Image(); imgWrap[i].src = url[i]; &#125; // if( img.complete) &#123; // // 如果已有缓存时直接用回调函数 // val.setAttribute(&apos;src&apos;,url) // return // &#125; // img.onload = function ()&#123; // img.onload = null // &#125; &#125; preloadImg(urls) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式适配]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[接触过的适配方式适配的目的就是在不同的手机设配上展示的结果看起来一样的 在初次接触响应式布局时和移动端布局时，第一次知道了rem，em &gt; rem是想对于html的font-size的大小来 &gt; em是相对于当前的font-size的大小 慢慢的了解了其他适配方式首先不管哪种适配方式，都需要添加一个meta123&lt;!-- 快捷键是meta:vp --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no;&quot;&gt; 第一种方式 媒体查询在初学scss时，所使用的一种适配方式，现在响应式就是用的@media方法 通过使用断点来进行设置根目录的字体大小 由于市面上手机种类多，如果完全配置所需要的内容太多而放弃 123456789101112131415161718@media screen and (min-width: 375px)&#123; html &#123; font-size: 14.0625px; &#125;&#125;@media screen and (min-width: 360px)&#123; html &#123; font-size: 13.5px; &#125;&#125;@media screen and (min-width: 320px)&#123; html &#123; font-size: 12px; &#125;&#125;html &#123; font-size: 16px;&#125; 这是突然看见的一个版本： 使用了手淘的方式，通过动态改变字体大小来适应 使用sass的函数方法动态计算宽度 不知道是否是版本问题，跟字体大小偏小，虽然设置的是在750px下的，但在750px下的宽度去相比原始宽度小 代码如下：1234567891011121314151617181920&lt;!-- 需要先引入： --&gt;&lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt;&lt;!-- 这里定义初始字体大 根据原型图大小除10判断 --&gt;$base-font-size: 75px;@function px2rem($px) &#123; @return ($px / $base-font-size) * 1rem;&#125;&lt;!-- 根据原型图测量多少计算 --&gt;.box&#123; width: px2rem(180px); height: px2rem(180px);&#125;&lt;!-- 最后生成 在各个手机中的展示一致--&gt;.box &#123; width: 2.4rem; height: 2.4rem;&#125; 第二种方式 js控制在工作以后接触的这种方式，通过js判断手机屏幕来设置根元素的字体大小 通过屏幕宽度的占比设置根目录宽度，同样是基于750px的 但是书写的时候需要计算比较麻烦，比如45px时 需要设置 (45/37.5) rem 相对来讲不好计算 1234567&lt;!-- 获取手机屏幕的宽度 --&gt;var htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;&lt;!-- 获取根元素 --&gt;var htmlDom = document.getElementByTagHtml(&apos;html&apos;)[0]&lt;!-- 设置根元素字体 --&gt;htmlDom.style.fontSize = htmlWidth/20 + &apos;px&apos; 同样是js控制，设置份额是方便（在750下45/100,方便好算）1234var htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;var htmlDom = document.getElementsByTagName(&apos;html&apos;)[0]htmlDom.style.fontSize = htmlWidth/750*100 + &apos;px&apos;&lt;!-- 这样计算下来1rem = 100 px; 那么45px 时就为0.45px--&gt; 其他成熟好用的方法 第一种 rem + simple-flexible rem + simple-flexible（simple-flexible 的 Github 地址） 不需要全部，只需要一份flexible.min.js 或者flexible.js就行 根据测量进行转换比： 10px = 1rem 搭配 以下代码更为方便123456789$base-font-size: 75px;@function px2rem($px, $base-font-size: 75px) &#123; @return ($px / $base-font-size) * 0.75rem;&#125;&lt;!-- 可以直接计算 --&gt;.box&#123; width: px2rem(240px) height: px2rem(240px)&#125; 第二种 flex布局 现如今的flex的兼容性很不错，对于移动端布局也很方便 最后，一般来讲不推荐字体也使用rem；现在使用rem + flexible方法或者flex布局时最好的方法了移动端一像素问题刚开始工作的时候，没有注意到在手机上的边框看起来宽，因此需要修改才开始接触处理一像素的问题 最后使用css3的transform: scale() 缩放属性实现 既然使用scale() 了，就用height:1 来表示宽度，然后，缩小 12345.box&#123; height:1; background: #333; transform:scaleY(0.5)&#125; 使用伪类设置到div上 1234567div:after&#123; content:&apos;&apos;; display: block; width:100%; height:1px; transform: scaleY(0.5);&#125; 但这样只可以实现一条线，如果想实现边框都是一像素呢123456789div:after&#123; content:&apos;&apos;; display: block; width:200%; height:200%; border:1px solid red; transform: scale(0.5); transform-origin: top left &#125; 这样便实现了所有边框1px 总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.border-top::after&#123; content:&apos;&apos;; position: absolute; top: 0; left: 0; width:200%; height:1px; background:red; transform: scale(0.5); transform-origin: top left&#125;.border-bottom::after&#123; content:&apos;&apos;; position: absolute; bottom: 0; left: 0; width:200%; height:1px; background:red; transform: scale(0.5); transform-origin: top left&#125;.border-left::after&#123; content:&apos;&apos;; position: absolute; top: 0; left: 0; width:1px; height:200%; background:red; transform: scale(0.5); transform-origin: top left&#125;.border-right::after&#123; content:&apos;&apos;; position: absolute; top: 0; right: 0; width:1px; height:200%; background:red; transform: scale(0.5); transform-origin: top left&#125;.border::after&#123; content:&apos;&apos;; position: absolute; top: 0; left: 0; width:200%; height:200%; border:1px solid red; transform: scale(0.5); transform-origin: top left&#125; 最近更新 最近看到的一种方法代码1!function(e)&#123;function t(a)&#123;if(i[a])return i[a].exports;var n=i[a]=&#123;exports:&#123;&#125;,id:a,loaded:!1&#125;;return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var i=&#123;&#125;;return t.m=e,t.c=i,t.p=&quot;&quot;,t(0)&#125;([function(e,t)&#123;&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,&#123;value:!0&#125;);var i=window;t[&quot;default&quot;]=i.flex=function(e,t)&#123;var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i),l=o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i),c=l&amp;&amp;parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;),10)&gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;&amp;d[1]&gt;534||c||(s=1);var u=1/s,m=r.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);m||(m=r.createElement(&quot;meta&quot;),m.setAttribute(&quot;name&quot;,&quot;viewport&quot;),r.head.appendChild(m)),m.setAttribute(&quot;content&quot;,&quot;width=device-width,user-scalable=no,initial-scale=&quot;+u+&quot;,maximum-scale=&quot;+u+&quot;,minimum-scale=&quot;+u),r.documentElement.style.fontSize=a/2*s*n+&quot;px&quot;&#125;,e.exports=t[&quot;default&quot;]&#125;]); flex(100, 1); 这是阿里的高清方案布局代码有点是 应用方便，布局简单 因为比例是1rem = 100px,所以当我没测量的宽度为80px时，便可以写0.8rem，方便计算该方法是根据dpr调整页面 不用在意1px问题，也不需要写meta的viewport了，会自动生成 注意 缺点： 与以前的方法不同，这个是屏幕越大，展示的元素越多，以前是屏幕越大，元素越大 vw方式vw和vh是css3中的新单位，都是相对于视窗大小来决定的 100vw=document.body.clientWidth也就是1vw=1%；需要注意的是必须有meta标签的viewport在实际使用中的方式123456789101112131415161718&lt;!-- 比如设计稿是750的，那么1vm就是7.5，可以通过计算获取 --&gt;&lt;!-- 通过scss编译 --&gt;$base:750,@function vw($px,$base:750)&#123; @return $px/$base*100vw&#125;&lt;!-- 设定好了就不需要计算了，可以直接写测量值了 --&gt;比如宽度为200，高度为300，.box&#123; width: vw(200); height: vw(300);&#125;&lt;!-- 最后编译以后展示 --&gt;.box&#123; width: 26.66667vw; height: 40vw;&#125; 2018.8.2 更新1 .最近看到一份基于vue-cli配置移动端自适应 这份文档的所介绍的基本步骤如下： 首先安装lib-flexible 1234&lt;!-- 第一步 --&gt;npm install --save lib-flexible&lt;!-- 第二步 在main中使用 --&gt;import &apos;lib-flexible&apos; 接下来需要安装px2rem-loader 123456789101112&lt;!-- 第一步 --&gt;npm install px2rem-loader --S&lt;!-- 第二步 修改文件夹build下的utils.js--&gt;&lt;!-- 在cssloader下添加 --&gt; const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 75 &#125; &#125; &lt;!-- 在函数 function generateLoaders下修改为 --&gt; const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader] 最后重新启动vue即可以使用测量的宽度来些css样式：比如750宽度 写成750px; 完成上述以后，还有一些bug处理 在750px下，html的font-size的显示是54px;不能满足是75px的设定。此时可以修改原文件 123456789101112&lt;!-- 找到node_modules下 &gt; lib-flexible &gt; flexible.js --&gt;&lt;!-- 修改其中的判断 --&gt; function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; // if (width / dpr &gt; 540) &#123; // width = 540 * dpr; // &#125; var rem = width / 10; docEl.style.fontSize = rem + &apos;px&apos;; flexible.rem = win.rem = rem; &#125;&lt;!-- 这样就会显示正常 --&gt; 如果不想转化成rem，就像用px怎么解决 只要在后面写上注释 / no/就可以了 12如此时就不会转换成remheight: 86px; /* no*/ 最后需要注意的是css样式只有在正常写的情况下在会转换，在行内和@import下，不会转换]]></content>
      <categories>
        <category>CSS</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端，CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue实现URL不变的情况下，数据更新]]></title>
    <url>%2F2018%2F05%2F30%2Fvue%E5%AE%9E%E7%8E%B0URL%E4%B8%8D%E5%8F%98%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1. 第一种方式 因为所用的是elementui，因此给绑定事件12345678changeView(item) &#123; this.$router.push(&#123; path: item.path, query: &#123; t: +new Date() // 保证每次点击路由的query项都是不一样的，确保会重新刷新view &#125; &#125;) &#125; 会生成时间戳 通过在组件中watch监听，判断地址1234567watch: &#123; &apos;$route&apos;(to, from) &#123; if (to.path == &apos;/members/userlog&apos;) &#123; this.getList(); &#125; &#125;&#125;, 2. 第二种方式两种方式的方式其实是一样的，表现方式不同，缺点也一样 都有一串时间戳 同样是添加一个点击事件在 （打包以后发现，点击导航第一遍不跳转页面，只有第二遍才可以，应更改和上面第一种方式一样） 12345678910111213&lt;el-menu mode=&quot;vertical&quot; unique-opened :default-active=&quot;$route.path&quot; :collapse=&quot;isCollapse&quot; background-color=&quot;#304156&quot; text-color=&quot;#bfcbd9&quot; active-text-color=&quot;#409EFF&quot;&gt; &lt;sidebar-item :routes=&quot;routers&quot; @click.native=&quot;clickLink($route.path)&quot;&gt;&lt;/sidebar-item&gt;&lt;/el-menu&gt; clickLink(path) &#123; this.$router.push(&#123; path, query: &#123; t: +new Date() // 保证每次点击路由的query项都是不一样的，确保会重新刷新view &#125; &#125;) &#125; 这样以后就可以在组件中使用watch了 123456789created () &#123; this.fetchData()&#125;,watch: &#123; &apos;$route&apos;: &apos;fetchData&apos;&#125;,methods: &#123; fetchData () &#123; ... &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中引入jquery]]></title>
    <url>%2F2018%2F05%2F28%2FVue%E4%B8%AD%E5%BC%95%E5%85%A5jquery%2F</url>
    <content type="text"><![CDATA[第一种方式 安装jquery 1npm install --save jquery 在webpack.base.conf中设置 123456789101112resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), // 如果是自己下载的jq文件，则用下面方式修改为存放目录 // &apos;jquery&apos;: path.resolve(__dirname, &apos;../src/assets/libs/jquery/jquery.min&apos;), // 如果使用NPM安装的jQuery，则直接引入即可 &apos;jquery&apos;: &apos;jquery&apos; &#125; &#125;, 第二步也可不设置直接设置第三步添加一个plugins配置 12345678plugins: [// 3. 配置全局使用 jquery new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, jquery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; &#125;)], 最后使用123456import $ from &apos;jquery&apos;methods&#123; cons()&#123; console.log($) &#125;&#125; 第二种安装方式1234import $ from &apos;jquery&apos;Object.defineProperty(Vue.prototype, &apos;$&apos;, &#123; value: $ &#125;)&lt;!--通过这种方式可以使用--&gt;this.$调用 // 必须注意调用域 第三种方式在各个组件中引入，缺点是太繁琐]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt的学习]]></title>
    <url>%2F2018%2F05%2F28%2FNuxt%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习Nuxt.js的一些基础学习链接 官网 1. 关于Nuxt.jsNuxt.js 是一个基于Vue.js的通用应用框架，Nuxt.js 预设了利用Vue.js开发服务端渲染的应用所需要的各种配置 特性 基于vue.js 自动代码分成 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 Es6/Es7语法支持 打包和压缩js和css html头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式的预处理器 2. nuxt安装注意，推荐8版本以上的node来安装nuxt，否则会无法执行 安装vue-cli脚手架 1npm install vue-cli -g 安装nuxt 12vue init nuxt/starter // 会在当前文件夹下安装成功vue init nuxt-community/starter-template &lt;project-name&gt; // 后面指定文件夹 根据提示执行下一步 1234npm install // 第一种方式cd &lt;project-name&gt; // 第二种方式需要先进入文件夹npm install 执行程序(打开localhost:3000) 1npm run dev 3. 安装完成nuxt以后的目录12345678910111213141516|-- .nuxt // Nuxt自动生成，临时的用于编辑的文件，build|-- assets // 用于组织未编译的静态资源入LESS、SASS 或 JavaScript|-- components // 用于自己编写的Vue组件，比如滚动组件，日历组件，分页组件|-- layouts // 布局目录，用于组织应用的布局组件，不可更改。|-- middleware // 用于存放中间件|-- pages // 用于存放写的页面，我们主要的工作区域|-- plugins // 用于存放JavaScript插件的地方|-- static // 用于存放静态资源文件，比如图片|-- store // 用于组织应用的Vuex 状态管理。|-- .editorconfig // 开发工具格式配置|-- .eslintrc.js // ESLint的配置文件，用于检查代码格式|-- .gitignore // 配置git不上传的文件|-- nuxt.config.json // 用于组织Nuxt.js应用的个性化配置，已覆盖默认配置|-- package-lock.json // npm自动生成，用于帮助package的统一性设置的，yarn也有相同的操作|-- package-lock.json // npm自动生成，用于帮助package的统一性设置的，yarn也有相同的操作|-- package.json // npm包管理配置文件 配置在nuxt.config.json 中进行配置 123456&lt;!--配置css --&gt;css: [ &#123; src: &apos;~assets/css/main.css&apos;&#125; ] &lt;!--配置loader和配置webpack的一样--&gt; 配置ip和端口在package.json中设置 123456&quot;config&quot;:&#123; &quot;nuxt&quot;:&#123; &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;1818&quot; &#125; &#125; 4. 路由配置1 . 基础路由 在pages文件夹下创建一个user文件夹 在user文件夹下创建index.vue和one.vue 我们便可以 123&lt;li&gt;&lt;a href=&quot;/&quot;&gt;HOME&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/user&quot;&gt;index&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/user/one&quot;&gt;one&lt;/a&gt;&lt;/li&gt; 传参操作(推荐使用nuxt-link，和router-link一样) 1&lt;nuxt-link :to=&quot;&#123;name:&apos;user&apos;,params:&#123;id:3306&#125;&#125;&quot;&gt;index&lt;/nuxt-link&gt; 动态路由 在上面的基础上添加一个about文件夹 创建index.vue和_id.vue123&lt;li&gt;&lt;a href=&quot;/about/123&quot;&gt;one&lt;/a&gt;&lt;/li&gt;&lt;!--传参写法--&gt;&lt;nuxt-link :to=&quot;&#123;name:&apos;about-id&apos;,params:&#123;id:3306&#125;&#125;&quot;&gt;index&lt;/nuxt-link&gt; 上面两种方式获取参数的方式都是$route.params.id 其他的没有细看，需要查看 官网 Nuxt 提供了路由参数校验123456export default &#123; validate (&#123; params &#125;) &#123; // Must be a number return /^\d+$/.test(params.id) &#125;&#125; 如果校验方法返回的值不为 true， Nuxt.js 将自动加载显示 404 错误页面。 5. 过度动效 全局动效加page 123456789101112131415&lt;!--在全局样式文件 assets/main.css 里添加一下样式：--&gt;.page-enter-active, .page-leave-active &#123; transition: opacity .5s;&#125;.page-enter, .page-leave-active &#123; opacity: 0;&#125;&lt;!--然后添加到 nuxt.config.js 文件中：--&gt;module.exports = &#123; css: [ &apos;assets/main.css&apos; ]&#125; 页面过渡动效，和上面一样，把page改为自定义的 123456.test-enter-active, .test-leave-active &#123; transition: opacity .5s;&#125;.test-enter, .test-leave-active &#123; opacity: 0;&#125; 最后在需要的页面中使用123export default &#123; transition: &apos;test&apos;&#125; 6. 视图 默认模版1234567891011&lt;!--定制化默认的 html 模板，只需要在应用根目录下创建一个 app.html 的文件。--&gt;&lt;!DOCTYPE html&gt;&lt;html &#123;&#123; HTML_ATTRS &#125;&#125;&gt; &lt;head&gt; &#123;&#123; HEAD &#125;&#125; &lt;/head&gt; &lt;body &#123;&#123; BODY_ATTRS &#125;&#125;&gt; &#123;&#123; APP &#125;&#125; &lt;/body&gt;&lt;/html&gt; 这里的读取的是nuxt.config.js里的信息， 就是我们写的pages文件夹下的主体页面了,都需要大写，否则报错最后需要重启服务，否则报错 默认布局可通过添加 layouts/default.vue 文件来扩展应用的默认布局。 123&lt;template&gt; &lt;nuxt/&gt;&lt;/template&gt; 错误页面 123456789101112131415&lt;!--你可以通过编辑 layouts/error.vue 文件来定制化错误页面.--&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 v-if=&quot;error.statusCode === 404&quot;&gt;页面不存在&lt;/h1&gt; &lt;h1 v-else&gt;应用发生错误异常&lt;/h1&gt; &lt;nuxt-link to=&quot;/&quot;&gt;首 页&lt;/nuxt-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&apos;error&apos;], layout: &apos;blog&apos; // 你可以为错误页面指定自定义的布局&#125;&lt;/script&gt; 默认 Meta 标签在nuxt.config.js中的设置 123456789head: &#123; meta: [ &#123; charset: &apos;utf-8&apos; &#125;, &#123; name: &apos;viewport&apos;, content: &apos;width=device-width, initial-scale=1&apos; &#125; ], link: [ &#123; rel: &apos;stylesheet&apos;, href: &apos;https://fonts.googleapis.com/css?family=Roboto&apos; &#125; ]&#125; 个性化的meta标签 1234567891011121314151617181920&lt;template&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; title: &apos;hhh&apos; &#125; &#125;, head()&#123; return &#123; title: this.title, meta: [ &#123; hid: &apos;description&apos;, name: &apos;description&apos;, content: &apos;My custom description&apos; &#125; ] &#125; &#125;&#125;&lt;/script&gt; 7. asyncData方法我们可以在设置组件的数据之前能异步获取或处理数据。使用方法12345678export default &#123; asyncData (&#123; params &#125;) &#123; return axios.get(`https://my-api/posts/$&#123;params.id&#125;`) .then((res) =&gt; &#123; return &#123; title: res.data.title &#125; &#125;) &#125;&#125; 使用async或await方法123456export default &#123; async asyncData (&#123; params &#125;) &#123; let &#123; data &#125; = await axios.get(`https://my-api/posts/$&#123;params.id&#125;`) return &#123; title: data.title &#125; &#125;&#125; 8. 打包Nuxt的别名 因此可以 引入文件 通过npm run generate打包 如果没有服务器知识，可以1npm install -g live-server 在dist文件夹下执行live-server即可]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常用工具类的封装]]></title>
    <url>%2F2018%2F05%2F25%2Fjavascript%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[javascript 的一些封装来源链接 1. 类型判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187// 使用typeOf可以精确的判断基本数据类型，但不能精确判断其他类型// Object.prototype.String.call()可以// 判断是否是字符串function isString (val)&#123; return Object.prototype.toString.call(val).slice(8,-1) === &apos;String&apos;&#125;// 判断是否是数字类型function isNumber (val)&#123; return Object.prototype.toString.call(val).slice(8, -1) === &apos;Number&apos;&#125;// 判断是否是数组类型function isArray (val)&#123; return Object.prototypr.toString.call(val).slice(8, -1) === &apos;Array&apos;&#125;// 判断是否是对象类型function isObject (val)&#123; return Object.prototypr.toString.call(val).slice(8, -1) === &apos;Object&apos;&#125;// 判断是否是布尔类型function isBoolean (val)&#123; return Object.prototype.toString.call(val).slice(8, -1) === &apos;Boolean&apos;&#125;// 判断是否是时间function isDate (val)&#123; return Object.prototypr.toString.call(val).slice(8, -1) === &apos;Date&apos;&#125;// 判断是否是函数function isFunction(val)&#123; return Object.prototype.toString.call(val).slice(8, -1) === &apos;function&apos;&#125;// 是否为nullfunction isNUll(val)&#123; return Object.prototype.toString.call(val).solice(8, -1) === &apos;Null&apos;&#125;// 是否为undefindfunction isUndefined (val)&#123; return Object.prototype.toString.call(val).solice(8, -1) === &apos;Undefined&apos;&#125;// 返回falsefunction isFalse(val)&#123; if( val == &apos;&apos; || val == undefined || val == &apos;null&apos; || val == &apos;undefined&apos; || val == 0 || val == false || val == NaN) return true else return true&#125;// 返回truefunction isTrue (val) &#123; return !this.isFalse(val)&#125;// 判断是ios系统function isIos()&#123; var u = navigator.userAgent; if(u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1) &#123; // 安卓手机 return false &#125; else if ( u.indexOf(&apos;iPhone&apos;) &gt; -1)&#123; //苹果手机 return true &#125; else if (u.indexOf(&apos;iPad&apos;) &gt; -1) &#123;//iPad return false &#125; else if (u.indexOf(&apos;Windows Phone&apos;) &gt; -1) &#123;//winphone手机 return false &#125;else&#123; return false &#125;&#125;// 判断是否是pcfunction isPc()&#123; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,&quot;SymbianOS&quot;, &quot;Windows Phone&quot;,&quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for ( let i in Agents)&#123; if(userAgentInfo.indexOf(Agents[i]) &gt; 0 )&#123; flag = false break; &#125; &#125; return flag&#125;// 判断使用的浏览器function browserType()&#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器 var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器 var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1; //判断是否IE的Edge浏览器 var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器 var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器 var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断Chrome浏览器 if (isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if(fIEVersion == 7) return &quot;IE7&quot; else if(fIEVersion == 8) return &quot;IE8&quot;; else if(fIEVersion == 9) return &quot;IE9&quot;; else if(fIEVersion == 10) return &quot;IE10&quot;; else if(fIEVersion == 11) return &quot;IE11&quot;; else return &quot;IE7以下&quot;//IE版本过低 &#125; if (isFF) return &quot;FF&quot;; if (isOpera) return &quot;Opera&quot;; if (isEdge) return &quot;Edge&quot;; if (isSafari) return &quot;Safari&quot;; if (isChrome) return &quot;Chrome&quot;;&#125;function checkStr (str, type) &#123; switch (type) &#123; case &apos;phone&apos;: //手机号码 return /^1[3|4|5|6|7|8][0-9]&#123;9&#125;$/.test(str); case &apos;tel&apos;: //座机 return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str); case &apos;card&apos;: //身份证 return /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(str); case &apos;pwd&apos;: //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\w&#123;5,17&#125;$/.test(str) case &apos;postal&apos;: //邮政编码 return /[1-9]\d&#123;5&#125;(?!\d)/.test(str); case &apos;QQ&apos;: //QQ号 return /^[1-9][0-9]&#123;4,9&#125;$/.test(str); case &apos;email&apos;: //邮箱 return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); case &apos;money&apos;: //金额(小数点2位) return /^\d*(?:\.\d&#123;0,2&#125;)?$/.test(str); case &apos;URL&apos;: //网址 return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str) case &apos;IP&apos;: //IP return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str); case &apos;date&apos;: //日期时间 return /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/.test(str) || /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/.test(str) case &apos;number&apos;: //数字 return /^[0-9]$/.test(str); case &apos;english&apos;: //英文 return /^[a-zA-Z]+$/.test(str); case &apos;chinese&apos;: //中文 return /^[\u4E00-\u9FA5]+$/.test(str); case &apos;lower&apos;: //小写 return /^[a-z]+$/.test(str); case &apos;upper&apos;: //大写 return /^[A-Z]+$/.test(str); case &apos;HTML&apos;: //HTML标记 return /&lt;(&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*&gt;/.test(str); default: return true; &#125;&#125;// 严格的身份证校验function isCardID(sId) &#123; if (!/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(sId)) &#123; alert(&apos;你输入的身份证长度或格式错误&apos;) return false &#125; //身份证城市 var aCity=&#123;11:&quot;北京&quot;,12:&quot;天津&quot;,13:&quot;河北&quot;,14:&quot;山西&quot;,15:&quot;内蒙古&quot;,21:&quot;辽宁&quot;,22:&quot;吉林&quot;,23:&quot;黑龙江&quot;,31:&quot;上海&quot;,32:&quot;江苏&quot;,33:&quot;浙江&quot;,34:&quot;安徽&quot;,35:&quot;福建&quot;,36:&quot;江西&quot;,37:&quot;山东&quot;,41:&quot;河南&quot;,42:&quot;湖北&quot;,43:&quot;湖南&quot;,44:&quot;广东&quot;,45:&quot;广西&quot;,46:&quot;海南&quot;,50:&quot;重庆&quot;,51:&quot;四川&quot;,52:&quot;贵州&quot;,53:&quot;云南&quot;,54:&quot;西藏&quot;,61:&quot;陕西&quot;,62:&quot;甘肃&quot;,63:&quot;青海&quot;,64:&quot;宁夏&quot;,65:&quot;新疆&quot;,71:&quot;台湾&quot;,81:&quot;香港&quot;,82:&quot;澳门&quot;,91:&quot;国外&quot;&#125;; if(!aCity[parseInt(sId.substr(0,2))]) &#123; alert(&apos;你的身份证地区非法&apos;) return false &#125; // 出生日期验证 var sBirthday=(sId.substr(6,4)+&quot;-&quot;+Number(sId.substr(10,2))+&quot;-&quot;+Number(sId.substr(12,2))).replace(/-/g,&quot;/&quot;), d = new Date(sBirthday) if(sBirthday != (d.getFullYear()+&quot;/&quot;+ (d.getMonth()+1) + &quot;/&quot; + d.getDate())) &#123; alert(&apos;身份证上的出生日期非法&apos;) return false &#125; // 身份证号码校验 var sum = 0, weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2], codes = &quot;10X98765432&quot; for (var i = 0; i &lt; sId.length - 1; i++) &#123; sum += sId[i] * weights[i]; &#125; var last = codes[sum % 11]; //计算出来的最后一位身份证号码 if (sId[sId.length-1] != last) &#123; alert(&apos;你输入的身份证号非法&apos;) return false &#125; return true&#125; 2. 时间函数封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220// 格式化时间// 过滤日期/** * 格式化时间 * * @param &#123;time&#125; 时间 * @param &#123;cFormat&#125; 格式 * @return &#123;String&#125; 字符串 * * @example formatTime(&apos;2018-1-29&apos;, &apos;&#123;y&#125;/&#123;m&#125;/&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&apos;) // -&gt; 2018/01/29 00:00:00 */function parseTime(time, cFormat) &#123; if (arguments.length === 0) &#123; return null &#125; if ((time + &apos;&apos;).length === 10) &#123; time = +time * 1000 &#125; const format = cFormat || &apos;&#123;y&#125;-&#123;m&#125;-&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&apos; let date if (typeof time === &apos;object&apos;) &#123; date = time &#125; else &#123; date = new Date(parseInt(time)) &#125; const formatObj = &#123; y: date.getFullYear(), m: date.getMonth() + 1, d: date.getDate(), h: date.getHours(), i: date.getMinutes(), s: date.getSeconds(), a: date.getDay() &#125; const time_str = format.replace(/&#123;(y|m|d|h|i|s|a)+&#125;/g, (result, key) =&gt; &#123; let value = formatObj[key] if (key === &apos;a&apos;) return [&apos;一&apos;, &apos;二&apos;, &apos;三&apos;, &apos;四&apos;, &apos;五&apos;, &apos;六&apos;, &apos;日&apos;][value - 1] if (result.length &gt; 0 &amp;&amp; value &lt; 10) &#123; value = &apos;0&apos; + value &#125; return value || 0 &#125;) return time_str &#125; /** * 返回指定长度的月份集合 * * @param &#123;time&#125; 时间 * @param &#123;len&#125; 长度 * @param &#123;direction&#125; 方向： 1: 前几个月; 2: 后几个月; 3:前后几个月 默认 3 * @return &#123;Array&#125; 数组 * * @example getMonths(&apos;2018-1-29&apos;, 6, 1) // -&gt; [&quot;2018-1&quot;, &quot;2017-12&quot;, &quot;2017-11&quot;, &quot;2017-10&quot;, &quot;2017-9&quot;, &quot;2017-8&quot;, &quot;2017-7&quot;] */function getMonths(time, len, direction) &#123; var mm = new Date(time).getMonth(), yy = new Date(time).getFullYear(), direction = isNaN(direction) ? 3 : direction, index = mm; var cutMonth = function(index) &#123; if ( index &lt;= len &amp;&amp; index &gt;= -len) &#123; return direction === 1 ? formatPre(index).concat(cutMonth(++index)): direction === 2 ? formatNext(index).concat(cutMonth(++index)):formatCurr(index).concat(cutMonth(++index)) &#125; return [] &#125; var formatNext = function(i) &#123; var y = Math.floor(i/12), m = i%12 return [yy+y + &apos;-&apos; + (m+1)] &#125; var formatPre = function(i) &#123; var y = Math.ceil(i/12), m = i%12 m = m===0 ? 12 : m return [yy-y + &apos;-&apos; + (13 - m)] &#125; var formatCurr = function(i) &#123; var y = Math.floor(i/12), yNext = Math.ceil(i/12), m = i%12, mNext = m===0 ? 12 : m return [yy-yNext + &apos;-&apos; + (13 - mNext),yy+y + &apos;-&apos; + (m+1)] &#125; // 数组去重 var unique = function(arr) &#123; if ( Array.hasOwnProperty(&apos;from&apos;) ) &#123; return Array.from(new Set(arr)); &#125;else&#123; var n = &#123;&#125;,r=[]; for(var i = 0; i &lt; arr.length; i++)&#123; if (!n[arr[i]])&#123; n[arr[i]] = true; r.push(arr[i]); &#125; &#125; return r; &#125; &#125; return direction !== 3 ? cutMonth(index) : unique(cutMonth(index).sort(function(t1, t2)&#123; return new Date(t1).getTime() - new Date(t2).getTime() &#125;))&#125;/** * 返回指定长度的天数集合 * * @param &#123;time&#125; 时间 * @param &#123;len&#125; 长度 * @param &#123;direction&#125; 方向： 1: 前几天; 2: 后几天; 3:前后几天 默认 3 * @return &#123;Array&#125; 数组 * * @example date.getDays(&apos;2018-1-29&apos;, 6) // -&gt; [&quot;2018-1-26&quot;, &quot;2018-1-27&quot;, &quot;2018-1-28&quot;, &quot;2018-1-29&quot;, &quot;2018-1-30&quot;, &quot;2018-1-31&quot;, &quot;2018-2-1&quot;] */function getDays(time, len, diretion) &#123; var tt = new Date(time) var getDay = function(day) &#123; var t = new Date(time) t.setDate(t.getDate() + day) var m = t.getMonth()+1 return t.getFullYear()+&apos;-&apos;+m+&apos;-&apos;+t.getDate() &#125; var arr = [] if (diretion === 1) &#123; for (var i = 1; i &lt;= len; i++) &#123; arr.unshift(getDay(-i)) &#125; &#125;else if(diretion === 2) &#123; for (var i = 1; i &lt;= len; i++) &#123; arr.push(getDay(i)) &#125; &#125;else &#123; for (var i = 1; i &lt;= len; i++) &#123; arr.unshift(getDay(-i)) &#125; arr.push(tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()) for (var i = 1; i &lt;= len; i++) &#123; arr.push(getDay(i)) &#125; &#125; return diretion === 1 ? arr.concat([tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()]) : diretion === 2 ? [tt.getFullYear()+&apos;-&apos;+(tt.getMonth()+1)+&apos;-&apos;+tt.getDate()].concat(arr) : arr&#125;/** * @param &#123;s&#125; 秒数 * @return &#123;String&#125; 字符串 * * @example formatHMS(3610) // -&gt; 1h0m10s */function formatHMS (s) &#123; var str = &apos;&apos; if (s &gt; 3600) &#123; str = Math.floor(s/3600)+&apos;h&apos;+Math.floor(s%3600/60)+&apos;m&apos;+s%60+&apos;s&apos; &#125;else if(s &gt; 60) &#123; str = Math.floor(s/60)+&apos;m&apos;+s%60+&apos;s&apos; &#125;else&#123; str = s%60+&apos;s&apos; &#125; return str&#125;/*获取某月有多少天*/function getMonthOfDay (time) &#123; var date = new Date(time) var year = date.getFullYear() var mouth = date.getMonth() + 1 var days //当月份为二月时，根据闰年还是非闰年判断天数 if (mouth == 2) &#123; days = year % 4 == 0 ? 29 : 28 &#125; else if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) &#123; //月份为：1,3,5,7,8,10,12 时，为大月.则天数为31； days = 31 &#125; else &#123; //其他月份，天数为：30. days = 30 &#125; return days&#125;/*获取某年有多少天*/function getYearOfDay (time) &#123; var firstDayYear = this.getFirstDayOfYear(time); var lastDayYear = this.getLastDayOfYear(time); var numSecond = (new Date(lastDayYear).getTime() - new Date(firstDayYear).getTime())/1000; return Math.ceil(numSecond/(24*3600));&#125;/*获取某年的第一天*/function getFirstDayOfYear (time) &#123; var year = new Date(time).getFullYear(); return year + &quot;-01-01 00:00:00&quot;;&#125;/*获取某年最后一天*/function getLastDayOfYear (time) &#123; var year = new Date(time).getFullYear(); var dateString = year + &quot;-12-01 00:00:00&quot;; var endDay = this.getMonthOfDay(dateString); return year + &quot;-12-&quot; + endDay + &quot; 23:59:59&quot;;&#125;/*获取某个日期是当年中的第几天*/function getDayOfYear (time) &#123; var firstDayYear = this.getFirstDayOfYear(time); var numSecond = (new Date(time).getTime() - new Date(firstDayYear).getTime())/1000; return Math.ceil(numSecond/(24*3600));&#125;/*获取某个日期在这一年的第几周*/function getDayOfYearWeek (time) &#123; var numdays = this.getDayOfYear(time); return Math.ceil(numdays / 7);&#125; 3.数组操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 判断元素是否在数组中container( arr,val)&#123; return arr.indexOf(val) != -1 ?true:false&#125;// 排序/** * @param &#123;arr&#125; 数组 * @param &#123;type&#125; 1：从小到大 2：从大到小 3：随机 * @return &#123;Array&#125; */function sort (arr, type = 1) &#123; return arr.sort( (a, b) =&gt; &#123; switch(type) &#123; case 1: return a - b; case 2: return b - a; case 3: return Math.random() - 0.5; default: return arr; &#125; &#125;)&#125;// 去重function unique (arr)&#123; if( Array.hasOwnPrototypr(&apos;from&apos;))&#123;//hasOwnProperty用来判断一个对象是否有你给出名称的属性或对象 return Array.from(new Set(arr)) &#125;else&#123; var n = &#123;&#125;,r =[]; for( var i = 0;i&lt;arr.length;i++)&#123; if( !n[arr[i]] )&#123; n[arr[i]] = true; r.push(arr[i]) &#125; &#125; return r &#125;&#125;// 数组合并function union (a,b)&#123; var nweArr =a.concat(n); return this.unique(newArr) // 调用这个方法去重&#125;// 删除其中一个元素function remove(arr,ele)&#123; var index = arr.indexOf(ele); // 当前要删除的元素所在的下标 if( index &gt; -1)&#123; arr.splice(index, 1) &#125; return arr&#125;/*将类数组转换为数组的方法*/function formArray (ary) &#123; var arr = []; if(Array.isArray(ary)) &#123; arr = ary; &#125; else &#123; arr = Array.prototype.slice.call(ary); &#125;; return arr;&#125;// 最大值function max(arr)&#123; return Math.max.apply(null,arr)&#125;// 最小值function min(arr)&#123; return Math.min.apply(null,arr)&#125;// 求和function sum(arr)&#123; return arr.reduce( (pre, cur) =&gt; &#123; return pre +cur &#125;)&#125;// 平均值function average( arr)&#123; return this.sum(arr)/arr.length&#125; 4. String 字符串操作去掉空格12345678910111213141516&lt;!-- type 1 所有 2 前后 3 前 4 后 --&gt;trim( str, type)&#123; type = type || 1 switch (type) &#123; case 1: return str.replace(/\s+/g, &quot;&quot;); case 2: return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); case 3: return str.replace(/(^\s*)/g, &quot;&quot;); case 4: return str.replace(/(\s*$)/g, &quot;&quot;); default: return str; &#125;&#125; 大小写转化1234567891011121314151617181920212223242526272829&lt;!-- type 1 首字母大写 2 首字母小写 3 大小写转换 4 全部大写 5 全部小写 --&gt;changeCase (str, type) &#123; type = type || 4 switch (type) &#123; case 1: return str.replace(/\b\w+\b/g, function (word) &#123; return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); &#125;); case 2: return str.replace(/\b\w+\b/g, function (word) &#123; return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); &#125;); case 3: return str.split(&apos;&apos;).map( function(word)&#123; if (/[a-z]/.test(word)) &#123; return word.toUpperCase(); &#125;else&#123; return word.toLowerCase() &#125; &#125;).join(&apos;&apos;) case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125; 检测密码强度1234567891011121314151617181920checkPwd (str)&#123; var lv = 0; if( lv.length &lt; 6 )&#123; return LV &#125; if(/[0-9]/.test(str))&#123; lv++ &#125; if(/[a-z]/.test(str))&#123; lv++ &#125; if(/[A-Z]/.test(str))&#123; lv++ &#125; if(/[\.|-|_]/.test(str))&#123; lv++ &#125; return lv&#125; 5.Number随机数范围12345678910111213random(min,max)&#123; if(argument.length === 2)&#123; return Math.floor(min + Math.random()*((max+1)-min)) // 因为是向下取值 &#125;else&#123; return null &#125;&#125;random(min,max)&#123; var range = max-min ;// 得到随机区间 var rand = Math.random() // 得到随机值 return (min + Math.round(rand*range))&#125; 将阿拉伯数字翻译成中文大写12345678910111213141516171819202122232425262728293031323334353637383940numberToChinese (num) &#123; var AA = new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;); var BB = new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;); var a = (&quot;&quot; + num).replace(/(^0*)/g, &quot;&quot;).split(&quot;.&quot;), k = 0, re = &quot;&quot;; for(var i = a[0].length - 1; i &gt;= 0; i--) &#123; switch(k) &#123; case 0: re = BB[7] + re; break; case 4: if(!new RegExp(&quot;0&#123;4&#125;//d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;) .test(a[0])) re = BB[4] + re; break; case 8: re = BB[5] + re; BB[7] = BB[5]; k = 0; break; &#125; if(k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0) re = AA[0] + re; if(a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re; k++; &#125; if(a.length &gt; 1) // 加上小数部分(如果有小数部分) &#123; re += BB[6]; for(var i = 0; i &lt; a[1].length; i++) re += AA[a[1].charAt(i)]; &#125; if(re == &apos;一十&apos;) re = &quot;十&quot;; if(re.match(/^一/) &amp;&amp; re.length == 3) re = re.replace(&quot;一&quot;, &quot;&quot;); return re; 将数字转换成大写金额123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/*将数字转换为大写金额*/changeToChinese (Num) &#123; //判断如果传递进来的不是字符的话转换为字符 if(typeof Num == &quot;number&quot;) &#123; Num = new String(Num); &#125;; Num = Num.replace(/,/g, &quot;&quot;) //替换tomoney()中的“,” Num = Num.replace(/ /g, &quot;&quot;) //替换tomoney()中的空格 Num = Num.replace(/￥/g, &quot;&quot;) //替换掉可能出现的￥字符 if(isNaN(Num)) &#123; //验证输入的字符是否为数字 //alert(&quot;请检查小写金额是否正确&quot;); return &quot;&quot;; &#125;; //字符处理完毕后开始转换，采用前后两部分分别转换 var part = String(Num).split(&quot;.&quot;); var newchar = &quot;&quot;; //小数点前进行转化 for(var i = part[0].length - 1; i &gt;= 0; i--) &#123; if(part[0].length &gt; 10) &#123; return &quot;&quot;; //若数量超过拾亿单位，提示 &#125; var tmpnewchar = &quot;&quot; var perchar = part[0].charAt(i); switch(perchar) &#123; case &quot;0&quot;: tmpnewchar = &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar = &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar = &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar = &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar = &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar = &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar = &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar = &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar = &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar = &quot;玖&quot; + tmpnewchar; break; &#125; switch(part[0].length - i - 1) &#123; case 0: tmpnewchar = tmpnewchar + &quot;元&quot;; break; case 1: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;; break; case 2: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;; break; case 3: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;; break; case 4: tmpnewchar = tmpnewchar + &quot;万&quot;; break; case 5: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;; break; case 6: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;; break; case 7: if(perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;; break; case 8: tmpnewchar = tmpnewchar + &quot;亿&quot;; break; case 9: tmpnewchar = tmpnewchar + &quot;拾&quot;; break; &#125; var newchar = tmpnewchar + newchar; &#125; //小数点之后进行转化 if(Num.indexOf(&quot;.&quot;) != -1) &#123; if(part[1].length &gt; 2) &#123; // alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;); part[1] = part[1].substr(0, 2) &#125; for(i = 0; i &lt; part[1].length; i++) &#123; tmpnewchar = &quot;&quot; perchar = part[1].charAt(i) switch(perchar) &#123; case &quot;0&quot;: tmpnewchar = &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar = &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar = &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar = &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar = &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar = &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar = &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar = &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar = &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar = &quot;玖&quot; + tmpnewchar; break; &#125; if(i == 0) tmpnewchar = tmpnewchar + &quot;角&quot;; if(i == 1) tmpnewchar = tmpnewchar + &quot;分&quot;; newchar = newchar + tmpnewchar; &#125; &#125; //替换所有无用汉字 while(newchar.search(&quot;零零&quot;) != -1) newchar = newchar.replace(&quot;零零&quot;, &quot;零&quot;); newchar = newchar.replace(&quot;零亿&quot;, &quot;亿&quot;); newchar = newchar.replace(&quot;亿万&quot;, &quot;亿&quot;); newchar = newchar.replace(&quot;零万&quot;, &quot;万&quot;); newchar = newchar.replace(&quot;零元&quot;, &quot;元&quot;); newchar = newchar.replace(&quot;零角&quot;, &quot;&quot;); newchar = newchar.replace(&quot;零分&quot;, &quot;&quot;); if(newchar.charAt(newchar.length - 1) == &quot;元&quot;) &#123; newchar = newchar + &quot;整&quot; &#125; return newchar; &#125; 6 操作dom元素封装$,选择元素12345678910111213$ (selector)&#123; var type = selector.substring(0,1) ;拿到第一个字符 if( type == &apos;#&apos;)&#123; if( document.querySelector ) return document.querySelector(selector) return document.getElementById(selector.subString(1)) &#125; if( type == &apos;.&apos;)&#123; if(document.querySelectorAll) return document.querySelectorAll(selector) return document.getElementsByClassName(selector.substring(1)) &#125;else&#123; return document[&apos;querySelectorAll&apos; ? &apos;querySelectorAll&apos;:&apos;getElementsByTagName&apos;](selector) &#125;&#125; 检测类名是否存在123hasClass( ele,name )&#123; return ele.className.match(new RegExp(&apos;(\\s|^)&apos; + name + &apos;(\\s|$)&apos;))&#125; 添加类名12345addClass( ele,name)&#123; if( !this.hasClass(ele,name))&#123; ele.className += &apos;&apos; +name; &#125;&#125; 删除类名123456removeClass (ele, name) &#123; if (this.hasClass(ele, name)) &#123; var reg = new RegExp(&apos;(\\s|^)&apos; + name + &apos;(\\s|$)&apos;); ele.className = ele.className.replace(reg, &apos;&apos;); &#125;&#125; 替换类名1234replaceClass (ele, newName, oldName) &#123; this.removeClass(ele, oldName); this.addClass(ele, newName);&#125; 获取兄弟节点12345678910siblings (ele) &#123; console.log(ele.parentNode) var chid = ele.parentNode.children,eleMatch = []; for(var i = 0, len = chid.length; i &lt; len; i ++)&#123; if(chid[i] != ele)&#123; eleMatch.push(chid[i]); &#125; &#125; return eleMatch;&#125; 获取行间样式属性1234567getByStyle (obj,name)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[name]; &#125;else&#123; return getComputedStyle(obj,false)[name]; &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue从头搭建后台管理四-首页]]></title>
    <url>%2F2018%2F05%2F02%2Fvue%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%9B%9B-%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[首页搭建首先后台模块需要固定的结构 创建layout文件夹 &gt; layout.vue 创建右边路由导航栏 创建sidebar文件夹 在sidebar下创建index.vue以及sidebarItem.vue 使用elementUI的导航模块NavMenu 具体代码 查看 右侧导航完成以后创建头部导航 NavBar.vue 查看 改组件中引用的组件来自公共组件 最后需要中间部分创建main.vue123456789101112131415&lt;template&gt; &lt;section class=&quot;app-main&quot;&gt; &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;AppMain&apos;,&#125;&lt;/script&gt; 注意如果想在路由中添加子路由必须要在父组件中有1&lt;router-view/&gt; 创建首页 创建dashboard文件夹 &gt; index.vue index.vue中负责引入各种组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;dashboard-container&quot;&gt; &lt;div class=&quot;dashboard-editor-container&quot;&gt; &lt;panl-group @handleSetLineChartData=&quot;handleSetLineChartData&quot; &gt;&lt;/panl-group&gt; &lt;el-row class=&quot;lineChart&quot;&gt; &lt;line-chart :chart-data=&quot;lineChartData&quot;&gt;&lt;/line-chart&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import PanlGroup from &apos;./components/PanelGroup&apos;import LineChart from &apos;./components/LineChart&apos;const lineChartData = &#123; newVisitis: &#123; expectedData: [100, 120, 161, 134, 105, 160, 165], actualData: [120, 82, 91, 154, 162, 140, 145] &#125;, messages: &#123; expectedData: [200, 192, 120, 144, 160, 130, 140], actualData: [180, 160, 151, 106, 145, 150, 130] &#125;, purchases: &#123; expectedData: [80, 100, 121, 104, 105, 90, 100], actualData: [120, 90, 100, 138, 142, 130, 130] &#125;, shoppings: &#123; expectedData: [130, 140, 141, 142, 145, 150, 160], actualData: [120, 82, 91, 154, 162, 140, 130] &#125;&#125;export default &#123; name: &apos;dashboard&apos;, components: &#123; PanlGroup, LineChart, &#125;, data() &#123; return &#123; name: &apos;管理员&apos;, lineChartData: lineChartData.newVisitis &#125; &#125;, methods: &#123; &lt;!-- 通过子组件的on事件传过来 --&gt; handleSetLineChartData(item) &#123; this.lineChartData = lineChartData[item] &#125; &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;.dashboard &#123; &amp;-text &#123; font-size: 30px; line-height: 46px; &#125; &amp;-editor-container&#123; margin-top: 50px; padding: 30px; background: #f0f2f5; &#125;&#125;&lt;/style&gt; 既然引用了两个组件，则新建这两个组件PanelGroup以及LineChart PanelGroup组件主要是面板组，通过使用elm组件实现 ,具体代码查看123456789101112131415161718&lt;!-- html部分 --&gt;&lt;template&gt; &lt;el-row :gutter=&quot;40&quot; class=&quot;panpel-group&quot;&gt; &lt;el-col :xs=&quot;12&quot; :sm=&quot;12&quot; :lg=&quot;6&quot; class=&quot;card-panpel-col&quot; v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot; &gt; &lt;!-- &lt;el-card shadow=&quot;hover&quot;&gt; --&gt; &lt;div class=&quot;card-panpel&quot; @click=&quot;handleSetLineChartData(item.data)&quot;&gt; &lt;div class=&quot;card-panpel-icon-wrapper&quot; :class=&quot;&apos;icon-&apos;+item.type&quot;&gt; &lt;svg-icon :icon-class=&apos;item.type&apos; class-name=&quot;card-panel-icon&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;card-panpel-description&quot;&gt; &lt;div class=&quot;card-panpel-text&quot;&gt;&#123;&#123;item.message&#125;&#125;&lt;/div&gt; &lt;count-to class=&quot;card-panpel-num&quot; :startVal=&apos;item.startVal&apos; :endVal=&apos;item.endVal&apos; :duration=&apos;item.duration&apos;&gt;&lt;/count-to&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt; 通过代码可以看出，用到了v-for，因此在data中我定义了items12345678910111213141516171819202122232425262728293031323334items: [ &#123; type: &apos;peoples&apos;, message: &apos;注册人数&apos;, startVal: 0, endVal: 88246, duration: 2200, data: &apos;newVisitis&apos; &#125;, &#123; type: &apos;message&apos;, message: &apos;消息&apos;, startVal: 0, endVal: 89365, duration: 2600, data: &apos;messages&apos; &#125;, &#123; type: &apos;money&apos;, message: &apos;消费&apos;, startVal: 0, endVal: 95612, duration: 3200, data: &apos;purchases&apos; &#125;, &#123; type: &apos;shoppingCard&apos;, message: &apos;购物&apos;, startVal: 0, endVal: 45646, duration: 3600, data: &apos;shoppings&apos; &#125; ] 同时用到了vue-count-to组件，来让数字持续增长，具体用法查看 LineChart是使用的echart.js,具体代码查看 实现点击PanelGroup的每一个卡片，让 LineChart 切换 12345678910&lt;!-- 通过emit导出 --&gt;handleSetLineChartData(item) &#123; this.$emit(&apos;handleSetLineChartData&apos;, item)&#125;&lt;!-- 在index.js中使用改事件，子传父 --&gt;handleSetLineChartData(item) &#123; this.lineChartData = lineChartData[item]&#125;将lineChartData通过prop传给LineChart组件 完成页面以后配置路由 12345678910111213141516171819export const constantRouterMap = [ &#123; path: &apos;/login&apos;, component: () =&gt; import(&apos;@/views/login/index&apos;), hidden: true &#125;, &#123; path: &apos;&apos;, name: &apos;dashboard&apos;, component: Layout, redirect: &apos;index&apos;, children: [&#123; path: &apos;index&apos;, name: &apos;dashboard&apos;, component: () =&gt; import(&apos;@/views/pages/dashboard/index&apos;), meta: &#123; title: &apos;dashboard&apos;, icon: &apos;dashboard&apos; &#125; &#125;] &#125;] export default new Router(&#123; // mode: &apos;history&apos;, // 后端支持可开 scrollBehavior: () =&gt; (&#123; y: 0 &#125;), // 当转到一个新的页面时，定位到最顶端。 routes: constantRouterMap&#125;) npm run dev启动即可]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue从头搭建后台管理三-目录结构]]></title>
    <url>%2F2018%2F05%2F02%2Fvue%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E4%B8%89-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[目录结构1234567891011121314151617181920212223242526├── Readme.md // help├── app // 应用├── config // 配置│ ├── default.json│ ├── dev.json // 开发环境│ ├── experiment.json // 实验PP│ ├── index.js // 配置控制│ ├── local.json // 本地│ ├── production.json // 生产环境│ └── test.json // 测试环境├── data├── doc // 文档├── environment├── gulpfile.js├── locales├── logger-service.js // 启动日志配置├── node_modules├── package.json├── app-service.js // 启动应用配置├── static // web静态资源加载│ └── initjson│ └── config.js // 提供给前端的配置├── test├── test-service.js└── toolsP]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用svg的方法]]></title>
    <url>%2F2018%2F05%2F02%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8svg%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第一种方法 在src下创建一个icons文件夹，再创建一个svg和一个index.js svg文件夹中放入所有的svg 创建一个组件SvgIcon代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;svg-icon&apos;, props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass() &#123; if (this.className) &#123; return &apos;svg-icon &apos; + this.className &#125; else &#123; return &apos;svg-icon&apos; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 在icons中的index.js中全局注册组件 1234567&lt;!--首先引入组件--&gt;import Vue from &apos;vue&apos;import SvgIcon from &apos;@/components/SvgIcon&apos;// svg组件&lt;!--注册组件--&gt;Vue.component(&apos;svg-icon&apos;,SvgIcon) 在代码中使用 12&lt;!--name就是所要使用的svg名称--&gt;&lt;svg-icon icon-class=&quot;name&quot;&gt;&lt;/svg-icon&gt; 进一步使用，由于是用js生成的svg代码，不够直观缺点 不能按需加载自定义性差添加不友善 因此我们通过使用svg-sprite-loader来实现多个svg的打包 首先安装svg-sprite-loader 1npm install svg-sprite-loader --save 在vue的build &gt; webpack.base.conf.js中添加svg的模块 1234567891011121314151617&#123; test: /\.svg$/, loader: &apos;svg-sprite-loader&apos;, include: [resolve(&apos;src/icons&apos;)], options: &#123; symbolId: &apos;icon-[name]&apos; &#125;&#125;,&#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: &apos;url-loader&apos;, exclude: [resolve(&apos;src/icons&apos;)], // 这个方法是不包含不打包 options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125;&#125;, 自动导入 在index.js中添加如下代码 123const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context(&apos;./svg&apos;, false, /\.svg$/)requireAll(req) 最后使用 123&lt;!--icon-class是所使用的svg名--&gt;&lt;!--class-name是图标的类名控制--&gt;&lt;svg-icon icon-class=&apos;language&apos; class-name=&quot;card-panel-icon&quot; /&gt; 10 .重点是要引入1import &apos;@/icons&apos; 学习地址 第二种方法 与svg同级创建一个svg文件夹，放入需要的svg 使用vue-svgicon 通过文档实现svg的使用 简单用法123456789101112131415npm install vue-svgicon --save-dev &lt;!--配置--&gt;&quot;svg&quot;: &quot;vsvg -s ./static/svg/src -t ./src/icons&quot;&lt;!--main.js中--&gt;import * as svgicon from &apos;vue-svgicon&apos;Vue.use(svgicon, &#123; tagName: &apos;svgicon&apos;&#125;)&lt;!--home.vue中使用--&gt;&lt;svgicon name=&quot;vue&quot;&gt;&lt;/svgicon&gt;&lt;!--执行--&gt;npm run svg]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive]]></title>
    <url>%2F2018%2F05%2F02%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[keep-alive官网介绍 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染 根据实践我理解为如果该组件经过了keep-alive那么前进后退回到该页面，会保持原样，不在有变化 在实际使用中 12345678&lt;!--一包裹组件--&gt;&lt;keep-alive&gt; &lt;component :is=&quot;home&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;!--二包裹路由--&gt;&lt;keep-alive&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 在2.1中新增了两个属性 include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 使用方式如下123456&lt;!--在router中定义a,b两个路由--&gt;&lt;!--a被缓存，b不被缓存--&gt;&lt;keep-alive include=&quot;a&quot;&gt; &lt;router-view/&gt;&lt;keep-alive&gt;&lt;router-view/&gt; 结合vue-router的meta属性 12345&lt;!--实现需要缓存与不需要缓存的--&gt;&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 具体例子参考 vue-router 之 keep-alive，作者：RoamIn]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绑定coding]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%BB%91%E5%AE%9Acoding%2F</url>
    <content type="text"><![CDATA[hexo绑Coding第一步 登录官网登录账户 创建新项目 完成以后，配置hexo，详细查看当前地址 由于已经绑定过github,因此需要绑定一致的ssh 地址C:\Users\DELL.ssh\id_rsa 如果不在搜索id_rsa即可 直接把id_rsa中的copy过去就可5.绑定完成以后打开hexo的配置123456deploy: type: git repository: github: git@github.com:name/name.github.io.git coding: git@git.coding.net:name/name.git // 在项目中选择ssh copy即可 branch: master 修改 1234567# URL 网址## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://qinmx.coding.me/ # 网址root: / # 网站根目录permalink: :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久连接中各部分的默认值 最后完成执行 hexo s 预览 12345hexo cleanhexo ghexo d 上传以后在项目的Pages服务&gt; 部署来源&gt; 选择master&gt; 保存 &gt; 等几分钟，点击网址跳转即可]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue从头搭建后台管理二-登录篇]]></title>
    <url>%2F2018%2F04%2F17%2Fvue%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E4%BA%8C-%E7%99%BB%E5%BD%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[实现基本登录功能前面已经按照官网实现了最基本的功能，接下来实现基本登录功能 第一步 创建页面 在src文件下创建一个views的文件夹，并创建一个login的文件夹 创建新页面登录 直接使用了elementUI的form表单 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!--HTML代码--&gt;&lt;template&gt; &lt;div class=&quot;login-contaier&quot;&gt; &lt;el-form ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; :rules=&quot;rules&quot; class=&quot;login-form&quot;&gt; &lt;h3&gt;&#123;&#123;context&#125;&#125;&lt;/h3&gt; &lt;!-- 用户名 --&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt; &lt;el-input type=&quot;text&quot; v-model=&quot;loginForm.username&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 密码 --&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input type=&quot;password&quot; v-model=&quot;loginForm.password&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; :loading=&quot;loading&quot; @click.native.prevent=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;!--js代码--&gt;&lt;script&gt; import &#123; isvalidUsername &#125; from &apos;utils/validate&apos; export default &#123; name: &apos;login&apos;, data() &#123; const validateUsername = (rule, value, callback) =&gt; &#123; if (!isvalidUsername(value)) &#123; callback(new Error(&apos;请输入正确的用户名&apos;)) &#125; else &#123; callback() &#125; &#125; const validatePassword = (rule, value, callback) =&gt; &#123; if (value.length &lt; 6) &#123; callback(new Error(&apos;密码长度不能小于6位数&apos;)) &#125; else &#123; callback() &#125; &#125; return &#123; context: &apos;后台登录系统&apos;, loading: false, loginForm: &#123; username: &apos;&apos;, password: &apos;&apos; &#125;, rules: &#123; username: [&#123; required: true, trigger: &apos;blur&apos;, validator: validateUsername &#125;], password: [&#123; required: true, trigger: &apos;blur&apos;, validator: validatePassword &#125;] &#125; &#125; &#125;, methods: &#123; handleLogin() &#123; this.$refs.loginForm.validate((valid) =&gt; &#123; if (valid) &#123; this.loading = true this.$store.dispatch(&apos;LoginByUsername&apos;, this.loginForm) .then(res =&gt; &#123; this.loading = false this.$router.push(&#123; path: &apos;/&apos; &#125;) &#125;) &#125; else &#123; console.log(&apos;登录失败！&apos;) return false &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;!--样式--&gt;&lt;style lang=&quot;scss&quot; scoped&gt;$bgcolor: #2d3a4b;.login-contaier&#123; width: 100%; height: 100%; background-color:$bgcolor; background-size:cover; position: relative; .login-form&#123; position: absolute; left: 0; right: 0; width: 450px; padding: 25px 55px 45px; margin: 0 auto; background: #fff; border-radius: 3px; top: 50%; transform: translateY(-50%); &#125;&#125;&lt;/style&gt; 其实当完成html（不需要事件-变量之类）以及css代码以后，就可在router中配置路由，将hello的文件替换成当前的index，启动页面就可以看到登录页面了，具体样式，就和写普通页面一样 第二步引入上面代码所用到的文件html和css 首先页面我使用了elementUI，具体安装可以查看 官网通过 1234npm i element-ui -S // 安装&lt;!--引入--&gt;import ElementUI from &apos;element-ui&apos;;import &apos;element-ui/lib/theme-chalk/index.css&apos;; css 可以看到使用的是scss语法，因此需要安装依赖 12&quot;css-loader&quot;: &quot;^0.28.0&quot;,&quot;node-sass&quot;: &quot;^4.8.3&quot;, 如果忘记安装，在npm run dev的时候会提示安装相应的依赖 jsimport { isvalidUsername } from ‘utils/validate’ 这个主要模拟实现用户名的校验（基于element的表单校验） 真正的校验其实只需要判断长度即可 123456789const validateUser = (rule, value, callback) =&gt; &#123; value = value.trim(); if (value.length &lt; 4) &#123; callback(new Error(&apos;用户名不能少于4个字符&apos;)); &#125; else &#123; callback(); &#125; &#125;; // 剩下的通过发送接口去判断返回值 新建了views的同级utils文件夹&gt; validate（一些校验功能都写在这） 代码如下12345// 模拟登录接口export function isvalidUsername(str) &#123; const valid_map = [&apos;admin&apos;, &apos;editor&apos;] return valid_map.indexOf(str.trim()) &gt;= 0&#125; 接口 可以看到当前页面最主要的就是handleLogin这个登录事件 所有操作都在 12345this.$store.dispatch(&apos;LoginByUsername&apos;, this.loginForm).then((res) =&gt; &#123; this.$router.push(&#123; path: &apos;/&apos; &#125;); //登录成功之后重定向到首页&#125;).catch(err =&gt; &#123; this.$message.error(err); //登录失败提示错误&#125;); 中使用 通过mock模拟实现登录接口(并不会，直接使用的 花裤衩的代码 安装mock npm install mock –save-dev 创建mock文件夹&gt; index.js &gt; login.js mian.js中导入mock 1import &apos;./mock&apos; index.js 123456789import Mock from &apos;mockjs&apos;import loginAPI from &apos;./login&apos;// 登录相关Mock.mock(/\/login\/login/, &apos;post&apos;, loginAPI.loginByUsername)Mock.mock(/\/login\/logout/, &apos;post&apos;, loginAPI.logout)Mock.mock(/\/user\/info\.*/, &apos;get&apos;, loginAPI.getUserInfo)export default Mock login.js 12345678910111213141516171819202122232425262728293031323334import &#123; param2Obj &#125; from &apos;@/utils&apos;const userMap = &#123; admin: &#123; roles: [&apos;admin&apos;], token: &apos;admin&apos;, introduction: &apos;超级管理员&apos;, avatar: &apos;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&apos;, name: &apos;超级管理员&apos; &#125;, editor: &#123; roles: [&apos;editor&apos;], token: &apos;editor&apos;, introduction: &apos;普通管理员&apos;, avatar: &apos;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&apos;, name: &apos;普通管理员&apos; &#125;&#125;export default &#123; loginByUsername: config =&gt; &#123; const &#123; username &#125; = JSON.parse(config.body) return userMap[username] &#125;, getUserInfo: config =&gt; &#123; const &#123; token &#125; = param2Obj(config.url) if (userMap[token]) &#123; return userMap[token] &#125; else &#123; return false &#125; &#125;, logout: () =&gt; &apos;success&apos;&#125; 创建api文件夹&gt;login.js 之后新建的接口文档都是这么实现的12345678910111213141516171819202122232425262728293031323334import fetch from &apos;utils/fetch&apos;function loginByUsername(username, password) &#123; const data = &#123; username, password &#125; return fetch(&#123; url: &apos;/login/login&apos;, method: &apos;post&apos;, data &#125;)&#125;function logout() &#123; return fetch(&#123; url: &apos;/login/logout&apos;, method: &apos;post&apos; &#125;)&#125;function getUserInfo(token) &#123; return fetch(&#123; url: &apos;/user/info&apos;, method: &apos;get&apos;, params: &#123; token &#125; &#125;)&#125;export &#123; loginByUsername, logout, getUserInfo&#125; 因为要保存登录状态我们使用vuex来状态管理 vuex的学习推荐查看 技术胖 创建store文件夹 store index.js // vuex的主要文件夹 getters.js modules 文件夹 // 多个state模块 index.js内容 12345678910111213141516import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; //使用了vuex，说明需要安装，可以根据提示安装import user from &apos;./modules/user&apos; import getters from &apos;./getters&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; modules: &#123; user &#125;, getters&#125;)export default store getters.js文件 相当于对数据的一个过滤和加工，可以通过1this.$store.getters.state;// 获取值 123456789const getters = &#123; status: state =&gt; state.user.status, token: state =&gt; state.user.token, avatar: state =&gt; state.user.avatar, name: state =&gt; state.user.name, roles: state =&gt; state.user.roles&#125;export default getters user.js文件 需要添加变量就仿照这添加 mutations 在组件中数据可使用1this.$store.commit(&apos;SET_CODE&apos;,&apos;&apos;) // 设置值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import &#123; loginByUsername, logout, getUserInfo &#125; from &apos;@/api/login&apos;import &#123; getToken, setToken, removeToken &#125; from &apos;@/utils/auth&apos;const user = &#123; state: &#123; user: &apos;&apos;, status: &apos;&apos;, code: &apos;&apos;, token: getToken(), name: &apos;&apos;, avatar: &apos;&apos;, introduction: &apos;&apos;, roles: [], setting: &#123; articlePlatform: [] &#125; &#125;, mutations: &#123; SET_CODE: (state, code) =&gt; &#123; state.code = code &#125;, SET_TOKEN: (state, token) =&gt; &#123; state.token = token &#125;, SET_INTRODUCTION: (state, introduction) =&gt; &#123; state.introduction = introduction &#125;, SET_SETTING: (state, setting) =&gt; &#123; state.setting = setting &#125;, SET_STATUS: (state, status) =&gt; &#123; state.status = status &#125;, SET_NAME: (state, name) =&gt; &#123; state.name = name &#125;, SET_AVATAR: (state, avatar) =&gt; &#123; state.avatar = avatar &#125;, SET_ROLES: (state, roles) =&gt; &#123; state.roles = roles &#125; &#125;, actions: &#123; LoginByUsername(&#123; commit &#125;, userInfo) &#123; const username = userInfo.username.trim() return new Promise((resolve, reject) =&gt; &#123; loginByUsername(username, userInfo.password) .then(res =&gt; &#123; const data = res.data commit(&apos;SET_TOKEN&apos;, data.token) setToken(res, data.token) // 存到本地 resolve() &#125;) .catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;, // 获取用户信息 GetUserInfo(&#123; commit, state &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; getUserInfo(state.token).then(response =&gt; &#123; if (!response.data) &#123; // 由于mockjs 不支持自定义状态码只能这样hack reject(&apos;error&apos;) &#125; const data = response.data commit(&apos;SET_ROLES&apos;, data.roles) commit(&apos;SET_NAME&apos;, data.name) commit(&apos;SET_AVATAR&apos;, data.avatar) commit(&apos;SET_INTRODUCTION&apos;, data.introduction) resolve(response) &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;, // 登出 Logout(&#123; commit &#125;, state) &#123; return new Promise((resolve, reject) =&gt; &#123; logout(state.token).then(res =&gt; &#123; commit(&apos;SET_TOKEN&apos;, &apos;&apos;) commit(&apos;SET_ROLES&apos;, []) removeToken() // 存到本地 resolve() &#125;).catch(error =&gt; &#123; reject(error) &#125;) &#125;) &#125;, // 前端登出 FedLogOut(&#123; commit &#125;) &#123; return new Promise(resolve =&gt; &#123; commit(&apos;SET_TOKEN&apos;, &apos;&apos;) resolve() &#125;) &#125; &#125;&#125;export default user 最后auth中是封装了js-cookies方法123456789101112131415161718192021import Cookies from &apos;js-cookie&apos;const TokenKey = &apos;Admin-Token&apos;function getToken()&#123; return Cookies.get(TokenKey)&#125;function setToken(token) &#123; return Cookies.set(TokenKey, token)&#125;function removeToken() &#123; return Cookies.remove(TokenKey)&#125;export &#123; setToken, getToken, removeToken&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli的安装]]></title>
    <url>%2F2018%2F04%2F13%2Fvue-cli%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装vue-cli必要条件： 首先必须安装node，安装过程和qq安装过程一样，安装成功以后可以通过在控制台输入1node -v // 来判断当前是否安装成功，以及显示版本 这是vue所支持的版本信息1234&quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; &#125;, 版本不对可以通过卸载以后重新安装 – 比较彻底1npm uninstall node // 卸载 vue-cli的安装学习资料 首先全局安装vue 1npm install -g vue-cli 通过vue安装选择模版，新建项目 1vue init webpack vue-admin 之后根据需要，提示来选择 1234567Project name (vue-admin) //项目名称。一般回车即可Project description // 项目描述Authot // 作者Vue build（Use arrow keys） // 选择打包方式，有两种方式，默认一般Install vue-router //是否安装路由，YUse ESLint to lint your code? //格式检查工具，个人不推荐，项目推荐，能统一格式剩下的一般回车即可 安装完成以后根据提示操作 1234To get started: cd vue-admin2 npm run dev 访问http://localhost:8080/#/成功就说明安装成功 如何想要自启动，就修改config&gt;index.js下的文件1autoOpenBrowser: true, //默认是false改为true]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习]]></title>
    <url>%2F2018%2F04%2F08%2FMongoDB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.基本结构查看是否与数据库链接：db.runCommand({ping:1})例如 ：123456789101112var userName= &apos;MongoDB&apos;;var timeStamp = Date.parse(new Date()); // 生成时间戳var jsonDataBase = &#123; &quot;loginName&quot;: userName, &quot;loginTime&quot;: timeStamp &#125;; var db = connect(&apos;log&apos;); // 链接数据库 与use log 方法一样 db.login.insert(jsonDataBase); //插入数据 print(&apos;[demo]log print success&apos;); // 没有错误显示成功 当我们创建好数据以后，通过connect()（类似use db）链接到库，通过db.集合.insert(xxx)插入数据，通过print来提示（类似console.log） 2.修改数据 $set 修改数据 123var db = connect(&apos;co&apos;);db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$set&apos;:&#123;sex:0&#125;&#125;)print(&apos;修改成功&apos;) $unset 删除数据 123var db = connect(&apos;com&apos;);db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$unset&apos;:&#123;sex:0&#125;&#125;)print(&apos;删除成功&apos;) $inc 修改数值 123var db = connect(&apos;com&apos;);db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$inc&apos;:&#123;age: +2&#125;&#125;)print(&apos;年龄增加了2&apos;) multi 为true时表示全部修改 123var db = connect(&apos;com&apos;);db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$set&apos;:&#123;&apos;book&apos;:[]&#125;,&#123;multi:true&#125;)print(&apos;当前数据都添加了book这个属性&apos;) upsert 如果找不到数据时，插入这条数据（true，添加，false，不添加） 123var db = connect(&apos;com&apos;);db.login.update(&#123;loginTime:&apos;xxxxx&apos;&#125;,&#123;&apos;$set&apos;&#123;age: 20&#125;&#125;,&#123;upsert:true&#125;)print(&apos;没有这条数据就添加上&apos;) 3.修改数组的方法 $push 追加数组 123var db = connect(&apos;com&apos;);db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$push&apos;:&#123;&apos;book&apos;:&apos;draw&apos;&#125;)print(&apos;最后数据为&apos; &#123;book:[&apos;draw&apos;]&#125;) $pop 删除数组的值，1 从末尾，2从前端 12db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$pop&apos;:&#123;&apos;book&apos;:1&#125;);print(&apos;最后数据为&apos; &#123;book:[]&#125;) $addToSet 有则会修改，没有就添加 12db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$addToSet&apos;:&#123;&apos;book&apos;:&apos;MongoDB&apos;&#125;);print(&apos;最后数据为&apos; &#123;book:[&apos;MongoDB&apos;]&#125;) $each 批量添加 123var newBook = [&apos;code&apos;,&apos;js&apos;,&apos;css&apos;];db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$addToSet&apos;:&#123;insterset:&#123;$each:newBook&#125;&#125;&#125;)print(&apos;输出数据为：book:[&apos;code&apos;,&apos;js&apos;,&apos;css&apos;]&apos;) 数组定位修改 通过.int 12db.login.update(&#123;loginTime:&apos;userName&apos;&#125;,&#123;&apos;$set&apos;:&#123;insterset.2:&apos;html&apos;&#125;)print(&apos;输出数据为：book:[&apos;code&apos;,&apos;js&apos;,&apos;html&apos;]&apos;) 4.find的查询修饰符筛选返回的字段（单条件查询）1234db.workmate.find( &#123;age:&#123;$lt:30,$gt:25&#125;&#125;, &#123;name:1,_id:0&#125;) 当前代码返回的字段就是json格式，只返回name，其中1为true，0为false不返回 例子中的的符号表示 $lt 小于 $lte 小于等于 $gt 大于 $gte 大于等于 $ne 不等于多条件查询$in1234db.workmate.find( &#123;age:&#123;$in:[$25,30]&#125;&#125;, &#123;name:true,age:true._id:false&#125;) 当前查询的就是年龄是25岁和30岁的信息 $or123456789db.workmate.find( &#123; $or:[ &#123;age:&#123;$gt:30&#125;&#125;, &#123;name:&apos;XiaoWang&apos;&#125; ] &#125;, &#123;name:1,age:1,_id:0&#125;) 当前查询的是年龄是大于30的或者姓名是小王的数据 $and123456789db.workmate.find( &#123; $and:[ &#123;age:&#123;$gt:30&#125;&#125;, &#123;name:&apos;XiaoWang&apos;&#125; ] &#125;, &#123;name:1,age:1,_id:0&#125;) 当前查询的大于30的并且是小王的数据 $not12345678db.workmate.find( &#123;age:&#123; $not:&#123; $gt:20, $lt:30, &#125;&#125;&#125;, &#123;name:true,age:true._id:false&#125;) 查询的是大于20小于30以外的值 数组的查询 基本查询 12345* db.workmate.find(&#123; insterest:&apos;看电视&apos;&#125;,&#123;name:1,age:1&#125;) $all多项查询 123db.workmate.find(&#123; insterset:&#123;$all:[&apos;看电视&apos;,&apos;听歌&apos;]&#125;&#125;) $in 1234db.workmate.find( &#123;age:&#123;$in:[$25,30]&#125;&#125;, &#123;name:true,age:true._id:false&#125;) 只要满足一项就可以查出来 $size123db.workmate.find( &#123;insterest:&#123;$size:3&#125;&#125;) 会显示出当前有3个insterest的数据 $slice1234db.workmate.find( &#123;&#125;, &#123;name:1,interest:&#123;$slice:2&#125;,age:1,_id:0&#125; ) 会显示所有数据的interest的前两项 find的一些参数 limit 返回的数量 skip 跳过的个数 sort 排序，1表示从小到大，-1反之。例如 ：123var rs = db.workmate.find(&#123;&#125;, &#123;name:true,age:true,_id:false&#125;).limit(0).skip(2).sort(&#123;age:1&#125;);printjson(rs) 当前数据返回的是按年龄从小到大排序，跳过前两条数据以后的获取的数据 直接js运行，不再终端操作 forEach方法1234var rs = db.workmate.find()rs.forEach(result=&gt;&#123; printjson(result)&#125;) 查询性能一般我们使用find来查询数据，当数据多的时速度会很慢，因此我们通过建立索引来实现,快速查询 第一步建立索引1db.workmate.ensureIndex(&#123;name:1&#125;) 第二步查询现有索引1db.workmate.getIndexes() 第三步再次执行find会发现，时间缩短了1var rs = db.randomInfo.find(&#123;name:&apos;14455&apos;&#125;); 扩展当多个索引查询的时候使用hint(),可以指定优先索引查询 删除索引db.workmate.dropIndex(‘name_1’) 全文查询建立索引1db.info.ensureIndex(&#123;content:&apos;text&apos;&#125;); 全文查找1db.info.find($text:&#123;$search:&apos;看花花&apos;&#125;) $text 变色在全文索引中查找数据 search 所要查找的数据 空格 当我们查找多个词时，通过空格来区分 通过-来取下比如：’-看电视’，就不会查找改数据 转义符1db.info.find(&#123;$text:&#123;$search:&quot;\&quot;love PlayGame\&quot; drink&quot;&#125;&#125;) 表示搜索love playgame和drink 学习地址：http://jspang.com/2017/12/16/mongdb]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB基础学习]]></title>
    <url>%2F2018%2F04%2F06%2FMongoDB%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习地址：http://jspang.com/2017/12/16/mongdb 安装 安装教程 安装完成以后在d盘创建data\db文件夹以后通过命令 启动 12cd C:\Program Files\MongoDB\Server\3.6\bin //先进入C:\Program Files\MongoDB\Server\3.6\bin\mongod --dbpath d:\MongoDB\data\db 再启动一个cmd ，输入mongo连接数据库 Mongo常用命令学习链接 在MongoDB中使用语法javascript输出不用console.log().而是用print()基本命令1 show dbs 查看已有数据库，默认有admin config local use admin 进入数据库，成功提示 ： switched to db admin show collections 显示数据库中的集合 db 显示当前位置 基本命令2 use db ：如果没有当前库，会创建一个库，通过show collectios发现为空，说明集合为空，因此查询不出 db.集合.insert() ：新建数据集合插入数据 db.集合.find() ：查看集合的所有数据 db.集合.findOne() ： 查询第一个数据 db.集合.update({查询},{修改}) ：第一个是查询条件，第二个是要修改成的值 db.集合.remove({查询})：删除指定的数据 db.集合.drop() : 删除当前集合 db.dropDatabase() : 删除整个数据库 db.集合.stats() ：查询条数]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react出错问题]]></title>
    <url>%2F2018%2F03%2F28%2Freact%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[react的学习报错这个是没有找不到组件，需要export default1React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: object. You likely forgot to export your component from the file it&apos;s defined in, or you might have mixed up default and named imports. 出现这种问题一般需要，html标签包裹1234567891011ERROR in ./src/js/index.jsModule build failed: SyntaxError: D:/test/react/03-27/day1/src/js/index.js: Adjacent JSX elements must bewrapped in an enclosing tag (11:16) 9 | // &lt;div&gt; 10 | &lt;ComponentHeader&gt;&lt;/ComponentHeader&gt;&gt; 11 | &lt;h2&gt;页面主题&lt;/h2&gt; | ^ 12 | // &lt;/div&gt; 13 | 14 | ) 找不到this，说明丢失了原来的对象，因此使用bind(this)创建一个函数，使这个函数不论怎么调用都有同样的 this 值。1Cannot read property &apos;setState&apos; of undefined 使用proptypes的错误12345678910// 当为isRequired 的时，必须填，否则Warning: Failed prop type: The prop `username` is marked as required in `ComponentHeader`, but its value is `undefined`. in ComponentHeader (created by Index) in Index // 当类型不正确的时候 Warning: Failed prop type: Invalid prop `username` of type `number` supplied to `ComponentHeader`, expected `string`. in ComponentHeader (created by Index) in Index]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react接触]]></title>
    <url>%2F2018%2F03%2F28%2Freact%E6%8E%A5%E8%A7%A6%2F</url>
    <content type="text"><![CDATA[console的Rendering下的Paint Flashing可以高亮改变的内容 React基础学习react的环境配置与调试1.安装react12345678// 初始化npm init// 安装react和react-dom以及babel-preset-reactnpm install --save react react-dom babelify babel-preset-react// 安装npm install babel-preset-es2015 --save 2.配置webpack的设置创建名称webpack.config.js注意loaders =&gt; loader ,如果写错会报错查看是否引入地址正确，否则提示==Unexpected token== &lt;或者==Unexpected identifier== 具体查看webpack的构建 3.调试P浏览器插件 react-developer-tools react的jsx表达式 三元表达式 1234567891011import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;export default class ComponentMain extends React.Component&#123; render()&#123; var userName = &apos;admin&apos;; // 必须定义，否则报错 return( &lt;p&gt;&#123;userName==&apos;&apos;?&apos;用户不存在&apos;:&apos;用户名&apos; + userName&#125;&lt;/p&gt; ) &#125;&#125; 绑定变量的方式 123456&lt;!--通过&#123;&#125;来表示。例如--&gt;var userName = &apos;admin&apos;;var boolInput = false; &lt;input type=&quot;button&quot; value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt; 注释写法 12&lt;!--使用&#123;/**/&#125;--&gt; &#123;/* &lt;h2&gt;页面主体&lt;/h2&gt; */&#125; 解析html格式++需要注意的是容易引起xss攻击，小心使用++ 12&lt;!--使用dangerouslySetInnerHTML 来开启--&gt;dangerouslySetInnerHTML=&#123;&#123;__html: this.props.description&#125;&#125; 生命周期的学习首次实例化 getDeaultProps getInitialState componentWillMount render componentDidMount 实例化以后 getINitialState componentwillMount render componentDidMount 存在期(组件已存在时的状态改变) componentWillReceiveProps shouldCompoentUpdate componentWillUpdate render componentDidMount 销毁&amp;清理期 componentWillUnmount React组件生命周期过程说明 react的State和propsStete 一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等 State只会在当前组件中，不会污染其他组件12345678910111213141516import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;export default class ComponentHeader extends React.Component&#123; constructor()&#123; super() //调用基类的所有初始化方法 this.state =&#123; name : &apos;Hello World&apos; &#125; &#125; render()&#123; return( &lt;p&gt;&#123;this.state.name&#125;&lt;/p&gt; ) &#125;&#125; setState 更改state 1this.setState(&#123;name:&apos;哈哈&apos;&#125;) props属性对于模块是外来属性 1234&lt;!--例如在父组件--&gt;&lt;ComponentHeader username=&quot;adbc&quot; /&gt;&lt;!--子组件接受--&gt; &lt;p&gt;&#123;this.props.username&#125; &#123;this.state.name&#125;&lt;/p&gt; props属性验证 React.PropTypes提供各种验证器（validator）来验证传入数据的有效性。当向props传入无效数据时，React会在JavaScript控制台抛出警告。 PropTypes12345678910111213import PropTypes from &apos;prop-types&apos;; //必须先引入Mycomponent.propTypes =&#123; optional : React.PropTypes.arry,bool,func,number,object,string,symbol等&#125;// 设置默认值 (当父元素没有传)const defaultProps = &#123; use: &apos;这是一个默认的值&apos;&#125;Mycomponent.defaultProps = defaultProps想子组件传的太多可以使用&#123;...this.props&#125; react操作DOM的使用 第一种方式 1234var myispbq = document.getElementById(&apos;ispbq&apos;);ReactDom.findDOMNode(myispbq).style.color=&quot;red&quot;&lt;p id=&quot;ispbq&quot;&gt;sdf&lt;/p&gt; refs (只有虚拟dom插入文档之后，才能使用)和vue的refs类似，使用方法,直接操作dom节点 123var pbq = this.refs.ispbq;&lt;p onClick=&#123;this.handleChange&#125; ref=&quot;ispbq&quot;&gt;&lt;/p&gt; 组件共享Mixin （很少用）安装1npm i --save react-mixin@2 导入1import ReactMixin from &apos;react-mixin&apos; 使用1234import MixinLog from &apos;./Mixin&apos;ReactMinxin(BodyIndex.prototype,Mixinlog) 然后在需要的地方1MixinLog.log(); react-router 学习路径]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令学习]]></title>
    <url>%2F2018%2F03%2F23%2Fgit%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[git学习简介 git是一个免费开放源码分布式版本控制系统，设计用来处理所有从小到 非常大型的项目，速度和效率。2.git安装 git下载安装 安装完成后，在命令行输入12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; git的使用创建版本库 使用1.创建文件 1234mkdir githubcd githubpwd/xxx/xxx/github mkdir 创建新文件夹 cd github 跳转 pwd 查看当前目录 2.初始化1git init 运行以后生成看不见的.git 可以用++ls -ah++查看3.在当前目录下创建一个文本12345git status // 查看当前文件状态git add &lt;file&gt; // 把文件暂时存储到到仓库，其中file是存放文件地址，可以是*或. 表示全部文件git status // 查看变化git commit -m &apos;描述语言&apos; //提交修改git push //上传 使用git status 具体图片如下： 当前提示我文件修改过，未提交修改 使用git add test.txt 并没有输出东西 继续使用git status 当前提示为绿色，即我们要提交的 使用git commit -m “上传test.txt文件” 最后使用git status查看当前状态说明没有需要修改提交的文件了 如果修改了文件没有提交，我们可用 1git diff test.txt //查看 注：当使用git add 以后，最好git status查看再提交 使用git命令修改文件 删除文件 当我们提交文件以后 一般清情况可以用rm xxx删除本地，但git status时会提示我们那些文件删除，因此使用git rm xxx删除并且git commit 去提交如图： 要恢复删除用(必须是删除本地了，但版本库还有否则提示) 12$ git checkout -- test1.txt // 执行命令error: pathspec &apos;test1.txt&apos; did not match any file(s) known to git. 撤销删除 第一种状态是修改了，并没有git add。因此我们可以使用1git checkout -- xxx 第二种是已经添加到了。因此可以使用12git reset HEAD XXX// 然后使用第一种方法即可 最后可以用 cat test.txt 查看当前内容1234DELL@DESKTOP-IBS76B7 MINGW64 /d/test/github/Clocks- (master)$ cat test.txt修改依稀111圣诞 回退版本 我们可以用git log 查看版本记录 12345678910111213141516171819 DELL@DESKTOP-IBS76B7 MINGW64 /d/test/github/Clocks- (master)$ git logcommit a632c27392e74ca9dc6442ec103f1e8004fda806 (HEAD -&gt; master)Author: qin-mx &lt;qmx_914@163.com&gt;Date: Fri Mar 23 15:17:17 2018 +0800 删除test1.txt文件commit a62dbae304c8eb0754dca6b9e6b9f3f6d51c6c5fAuthor: qin-mx &lt;qmx_914@163.com&gt;Date: Fri Mar 23 15:16:28 2018 +0800 “上传test1.txt文件commit 330145dfa1bab8849f1e8baf245d74c1e99f5c88Author: qin-mx &lt;qmx_914@163.com&gt;Date: Fri Mar 23 15:16:04 2018 +0800 “修改test.txt文件 显示太多，可以用 –pretty=oneline来显示总要的 1234567 DELL@DESKTOP-IBS76B7 MINGW64 /d/test/github/Clocks- (master)$ git log --pretty=onelinea632c27392e74ca9dc6442ec103f1e8004fda806 (HEAD -&gt; master) 删除test1.txt文件a62dbae304c8eb0754dca6b9e6b9f3f6d51c6c5f “上传test1.txt文件330145dfa1bab8849f1e8baf245d74c1e99f5c88 “修改test.txt文件d8f63a310d8cb6ef53f272c6ddef30d72e7cb8f4 “上传test.txt文件2238472b7e73f6d8039bca32483a7360ca3c3e1e README 这次就少多了，还可以 –abbrev-commit再次缩减 123456 DELL@DESKTOP-IBS76B7 MINGW64 /d/test/github/Clocks- (master)$ git log --pretty=oneline --abbrev-commita632c27 (HEAD -&gt; master) 删除test1.txt文件a62dbae “上传test1.txt文件330145d “修改test.txt文件d8f63a3 “上传test.txt文件 其中的commit和‘a632c27..’这些就是版本号我们可以使用 1git reset --hard HEAD // 恢复到当前版本 同时查看git log 发现没有变化 如果想回退到以前打版本，就将HEAD变成版本号 12$ git reset --hard a632HEAD is now at a632c27 删除test1.txt文件 再次查看,之后修改的记录都没了 12 $ git log --pretty=oneline --abbrev-commit2238472 (HEAD -&gt; master) README 最后我们想恢复到之前的版本（当前版本的后面）git log 是查不到版本好的，使用 1git reflog 会展示所有记录选择适合的,执行$ git reset –hard xxxx 即可 123456789 $ git refloga632c27 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEADa632c27 (HEAD -&gt; master) HEAD@&#123;1&#125;: reset: moving to a6322238472 HEAD@&#123;2&#125;: reset: moving to 2238472a632c27 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit: 删除test1.txt文件a62dbae HEAD@&#123;4&#125;: commit: “上传test1.txt文件330145d HEAD@&#123;5&#125;: commit: “修改test.txt文件d8f63a3 HEAD@&#123;6&#125;: commit: “上传test.txt文件2238472 HEAD@&#123;7&#125;: commit (merge): README 标签管理 git tag v1.0 设置了标签 git tag 查看标签 git show v1.0 查看当前标签的信息 git tag -a v0.1 -m “version 0.1 released”版本号 建带有说明的标签 git tag -d v1.0 删除标签 例子 查看添加标签 1234567891011121314151617$ git tag v2.0 // 没有提示$ git tag // 有执行结果 v2.0v2.0$ git show v1.0 // 执行结果commit 831555421a02520876dfea77c5f256f6bc148dce (tag: v1.0, origin/master, origin/HEAD)Author: qin-mx &lt;qmx_914@163.com&gt;Date: Fri Mar 23 11:56:06 2018 +0800 继续 ddiff --git a/README b/README//添加有说明的标签$ git tag -a v2.1 -m &apos;a指定标签，m说明&apos; a62dbae//查看提示a62dbae (tag: v2.1) “上传test1.txt文件 删除标签 12 $ git tag -d v2.0 // 删除Deleted tag &apos;v2.0&apos; (was a632c27) 最后标签的其他方法： 1234567 命令git push origin &lt;tagname&gt;可以推送一个本地标签；命令git push origin --tags可以推送全部未推送过的本地标签；命令git tag -d &lt;tagname&gt;可以删除一个本地标签；命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 分支创建和管理 创建分支git checkout -b dev 12$ git checkout -b devSwitched to a new branch &apos;dev&apos; 查看当前所有分支 git branch，星号表示当前分支 123$ git branch* dev master 切换分支 git checkout master 1234$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits. (use &quot;git push&quot; to publish your local commits) 分支内容合并到master上 git merge dev 12345$ git merge devUpdating 831555...311Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 删除分支 git branch -d dev 1234$ git branch -d devDeleted branch dev (was a632c27).$ git branch* master 总结： git是分布式版本控制系统 git克隆项目以后可以在本地看的所有log git能在不联网的情况下合并分支提交代码 git可以多个版本库，和svn不同，只有一个版本库存放所有资源 git的上传拉去代码速度快，svn的慢 git所有分支基于一个项目，svn可以是某个目录下 git与github关联 查看 https://www.cnblogs.com/cxk1995/p/5800196.html https://blog.csdn.net/qazwsxpcm/article/details/68946736 参考：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000]]></content>
      <categories>
        <category>git</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2018%2F03%2F22%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文链接： https://juejin.im/post/5a998991f265da237f1dbdf9#comment 2018春招前端面试: 闯关记 | 掘金技术征文 前言去年年末研发组解散失业, so选择回去学车了,也顺利拿到了驾照 最近回归大深圳….开始踏上漫漫的找工作之路; “拉勾上吊一百年不匹配!!!”,”BOSS直聘日夜没反应!!!” 题目范围涵盖我最近遇到的笔试题和面谈的(CSS/JS/HTTP/Node/Hybrid/Vue/NG/React) emm…..这里不列举哪些公司了, 若是你完整的阅读一遍,相信你有不少的收获,谢谢阅读 截止目前(2018/3/22)总共汇总了120多个问题(我去面的创业,中大型皆有)…问题汇总,想到就写….Q: CSS 有哪些样式可以给子元素继承! 可继承的:font-size,font-weight,line-height,color,cursor等不可继承的一般是会改变盒子模型的:display,margin、border、padding、height等更加全面的可以到引擎找 Q: 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内: input,span,a,img以及display:inline的元素块级: p,div,header,footer,aside,article,ul以及display:block这些void: br,hrQ: CSS3实现一个扇形 思路跟画实体三角形一个道理,只不过多了一个圆角属性&lt;!DOCTYPE html&gt; 扇形 .sector { width: 0; height: 0; border-width: 50px; border-style: solid; border-color: #f00 transparent transparent; border-radius: 50px; } Q: box-sizing常用的属性有哪些? 分别有啥作用? box-sizing有两个值:content-box(W3C标准盒模型),border-box(怪异模型), 这个css 主要是改变盒子模型大小的计算形式 可能有人会问padding-box,这个之前只有 Firefox 标准实现了,目前50+的版本已经废除; 用一个栗子来距离,一个div的宽高分别100px,border为5px,padding为5px .test { box-sizing: content-box; border: 5px solid #f00; padding:5px; width: 100px; height: 100px; } &lt;!–content-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,也就是说 content + padding + border = 120px(盒子实际大小) 而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者content(80px) + padding(52px) + border(52px) = 100px–&gt; Q: 清除浮动的方式有哪些?比较好的是哪一种? 常用的一般为三种.clearfix, clear:both,overflow:hidden; 比较好是 .clearfix,伪元素万金油版本…后两者有局限性..等会再扯 .clearfix:after { visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } .clearfix:before, .clearfix:after { content:””; display:table;}.clearfix:after{ clear:both; overflow:hidden;}.clearfix{ zoom:1;} clear:both:若是用在同一个容器内相邻元素上,那是贼好的…有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷 overflow:hidden:这种若是用在同个容器内,可以形成 BFC避免浮动造成的元素塌陷 Q: CSS 中transition和animate有何区别? animate 如何停留在最后一帧! 这种问题见仁见智,我的回答大体是这样的..待我捋捋. transition一般用来做过渡的, 没时间轴的概念, 通过事件触发(一次),没中间状态(只有开始和结束) 而animate则是做动效,有时间轴的概念(帧可控),可以重复触发和有中间状态; 过渡的开销比动效小,前者一般用于交互居多,后者用于活动页居多; 至于如何让animate停留在最后一帧也好办,就它自身参数的一个值就可以了 animation-fill-mode: forwards;让我们来举个栗子….自己新建一个 html 跑一下…. &lt;!DOCTYPE html&gt; Box-sizing .test { box-sizing: border-box; border: 5px solid #f00; padding: 5px; width: 100px; height: 100px; position:absolute; / 简写的姿势排序 @keyframes name : 动画名 duration 持续时间 timing-function 动画频率 delay 延迟多久开始 iteration-count 循环次数 direction 动画方式,往返还是正向 fill-mode 一般用来处理停留在某一帧 play-state running 开始,paused 暂停 …. 更多的参数去查文档吧..我就不一一列举了 / animation: moveChangeColor ease-in 2.5s 1 forwards running; } @keyframes moveChangeColor { from { top:0%; left:5%; background-color:#f00 } to{ top:0%; left:50%; background-color:#ced; } } L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":50,"height":100},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false}); Q: 块级元素水平垂直居中的方法 我们要考虑两种情况,定宽高和不定宽高的; 方案 N 多种,我记得我很早写过这类的笔记 传送门:网页元素居中攻略记 Q: 说说样式权重的优先级; !important &gt; 行内样式 &gt; id &gt; class &gt; tag 样式权重可以叠加, 比如 id&gt;class Q: 对HTML语义化的理解 简言之:就是不滥用标签(比如 DIV)/随意嵌套(比如 span&gt;div) , 类的命名要合理, 利于浏览器解析乃至引擎收录,也利于团队协作和维护 Q: JS有几种数据类型,其中基本数据类型有哪些! 七种数据类型 BooleanNullUndefinedNumberStringSymbol (ECMAScript 6 新定义)Object(ES6之前)其中5种为基本类型:string,number,boolean,null,undefined, ES6出来的Symbol也是原始数据类型 ，表示独一无二的值 Object 为引用类型(范围挺大),也包括数组、函数, Q: null和undefined的差异 大体说一下,想要知其所以然请引擎搜索 相同点: 在 if判断语句中,值都默认为 false大体上两者都是代表无,具体看差异差异: null转为数字类型值为0,而undefined转为数字类型为 NaN(Not a Number)undefined是代表调用一个值而该值却没有赋值,这时候默认则为undefinednull是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)设置为null的变量或者对象会被内存收集器回收Q: JS 的DOM 操作(Node节点获取及增删查改); 获取(太多了,有document.getElementById/ClassName/Name/TagName 等,或者 querySelector) // example // get Nodevar element = document.querySelector(‘#test’); // 追加element.appendChild(Node); // 删除element.removeChild(Node); // 查找element.nextSibling // 获取元素之后的兄弟节点 , 会拿到注释文本,空白符这些element.nextElementSibling // 等同, 获取标签(不会拿到注释文本这些) element.previousSibling // 和上面同理,往前找兄弟节点element.previousElementSibling // 改动,比如 属性这些element.setAttribute(name, value); // 增加属性element.removeAttribute(attrName); //删除属性 // 来一个简易的练习题,随便一个网页追加插入一块DOM(非覆盖:不能 innerHTML);/* Hello, World*/ // 以上面的例子为例var test = document.createElement(‘div’); // 创建一个块级元素test.setAttribute(“id”,”test”); // 设置其id 属性var span = document.createElement(‘span’); // 创建一个 spanspan.innerText = “Hello,world”; // 插入 span 的文本内容test.appendChild(span); // 组合节点 element.appendChild(test); //追加到某个节点区域 Q: 给一个 DOM添加捕获和冒泡的两种写法的事件点击,谁先执行? 分情况分析: 有拿到节点的,优先捕获,没有才往上冒泡寻找若是通过node.addEventListener(‘event’,callback,bubble or capture); 谁先调用谁先执行stackoverflow 有相关的探讨: Event listeners registered for capturing phase not triggered before bubbling - why?Q: 谈谈你对ajax 的理解,以及用原生 JS 实现有哪些要点需要注意; ajax全称是异步 javascript 和 XML,用来和服务端进行数据交互的,让无刷新替换页面数据成了可能; 至于有哪些要要点,来一个简短的ajax请求 var xhr = new XMLHttpRequest(); // 声明一个请求对象 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ // readyState 4 代表已向服务器发送请求 if(xhr.status === OK){ // // status 200 代表服务器返回成功 console.log(xhr.responseText); // 这是返回的文本 } else{ console.log(“Error: “+ xhr.status); // 连接失败的时候抛出错误 } }} xhr.open(‘GET’, ‘xxxx’); // 如何设置请求头? xhr.setRequestHeader(header, value);xhr.setRequestHeader(‘Content-Type’, ‘application/json’); xhr.send(null); // get方法 send null(亦或者不传,则直接是传递 header) ,post 的 send 则是传递值 更为详细的可以阅读此处; &lt;&gt;&lt;&gt;Q: JS 实现一个闭包函数,每次调用都自增1; 这里主要考察了闭包,函数表达式以及 IIFE(立即执行表达式) var add = (function() { // 声明一变量,由于下面 return所以变量只会声明一次 var count = 0; return function() { return console.log(count++); };})(); add(); // 0add(); // 1add(); // 2 Q: [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么? [‘1’,’2’,’3’].map(parseInt); // [1,NaN,NaN] // 刨析 // map有三个参数:数组元素，元素索引，原数组本身// parseInt有两个参数,元素本身以及进制// 理清了这两个就好办了…// [‘1’,’2’,’3’].map(parseInt); 等于如下[‘1’,’2’,’3’].map(function(item,index,array){ return parseInt(item,index); // 是不是一目了然}); // parseInt(“1”,0); =&gt; 1// parseInt(“2”,1); =&gt; NaN// parseInt(“3”,2); =&gt; NaN Q: 对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序 我这里用的是结合 ES6的,代码量很短 //很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)// 结合…解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等 let arr = […new Set([‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’])].sort(function(a,b){ return a&lt;b ? -1:1; // 这里返回的是升序的,降序改下返回值就好了.所以是相对}) // [“2013-06-12”, “2014-02-22”, “2018-03-05”, “2019-03-12”] 对于数组去重的,有兴趣的可以看下我这篇水文: JS数组去重!!!一篇不怎么靠谱的”深度”水文Q: 对数组[1,2,3,4,5,’6’,7,’8’,’a’,’b’,’z’]进行乱序 // 我们依旧可以用上面的 sort 的原理实现乱序 let tempArr = [1,2,3,4,5,’6’,7,’8’,’a’,’b’,’z’].sort(function(){ return Math.random() &gt; 0.5 ? -1 : 1;}) // 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个//[“6”, “z”, 3, “b”, 5, 2, 7, “8”, “a”, 1, 4] 上面和这道题逗涉及到数组顺序的问题,想了解下为什么 a-b,a&gt;b这类可以更改排序 可以看看知乎对于这块的探讨: 传送门:javascript排序return a-b? Q: 求[1, 10, 11, -1,’-5’,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差 // 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的function MaxMinPlus(arr) { // 返回最大值与最小值之差 return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log(‘传入的不是数组亦或者未能解决的错误’)} // 结果是 20 // 若是要完善的话,要考虑传入的是非数组,//传入字符串的时候要判断,然后切割为数组..// 都要考虑进去代码量不短 Q: 请给Array实现一个方法,去重后返回重复的字符(新数组) var testArr = [1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3]; Array.prototype.extraChar = function(){ var cacheExtraChar = []; // 缓存重复出现的字符 var that = this; // 缓存 this; this.map(function(item,index){ // 怎么理解这段代码呢? // 就是向前往后查找一遍和从后往前查找一遍,不等就是没有重复 // 为什么还要判断一遍缓存,是过滤缓存数组内多次写入 (that.indexOf(item) !== that.lastIndexOf(item)) &amp;&amp; cacheExtraChar.indexOf(item) === -1 ? cacheExtraChar.push(item) : -1; }); return cacheExtraChar; } testArr.extraChar(); // [1, 3, 7, 2, 4] // 若是还需要排序就再排序下 [1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3].extraChar().sort(function(a,b){return a-b}) // [1, 2, 3, 4, 7] Q: 一个数组中 par中存放了多个人员的信息,每个人员的信息由 name 和 age 构成({name:’张三’,age:15}).请用 JS 实现年龄从小到大的排序; var par = [{age:5,name:’张三’},{age:3,name:’李四’},{age:15,name:’王五’},{age:1,name:’随便’}] var parSort = par.sort(function(a,b){ return a.age - b.age;})Q: 判断一个回文字符串和同字母异序字符串 回文字符串就是正序倒序都是一样的;同字母异序字符串则是字符串都一样,但是位置可能不一定一样,比如abcefd和dceabf=&gt;return true后者的思路就是用排序把异序扭正.. 普通版 // 回文判断 , 比如用 abcbavar isPalindromes = function(params){ params = params.toString().toLowerCase() return params === params.split(‘’).reverse().join(‘’);} // 同字母异序判定,比如abcefd和dceabfvar isAnagram = function(str1, str2) { str1 = str1.toString().toLowerCase(); str2 = str2.toString().toLowerCase(); return str1.split(‘’).sort().join(‘’) === str2.split(‘’).sort().join(‘’)} 进阶版:多一些特殊字符 若是我们要去除所有非字母数字的字符,则需要用到正则 // 进阶版: isPalindromes(‘abc_ &amp;b #@a’) var isPalindromes = function(params){ // 传入参数先转为字符串且全部转为小写,最后去除多余字符比较 params = params.toString().toLowerCase().replace(/[\W_\s]/g,’’); console.log(params) return params === params.split(‘’).reverse().join(‘’);} // 进阶版同字母异序: isAnagram(‘ab *&amp;cef#d’,‘!d@ce^abf’)var isAnagram = function(str1, str2) { str1 = str1.toString().toLowerCase().replace(/[\W_\s]/g,’’); str2 = str2.toString().toLowerCase().replace(/[\W_\s]/g,’’); return str1.split(‘’).sort().join(‘’) === str2.split(‘’).sort().join(‘’)} Q: JS 实现String.trim()方法; // 原生是有 trim()方法的.我们要模拟一个; String.prototype.emuTrim = function(){ // 这条正则很好理解,就是把头部尾部多余的空格字符去除 return this.replace(/(^\s)|(\s$)/g,’’);} ‘ fsaf fsdaf f safl lllll ‘.emuTrim(); //“fsaf fsdaf f safl lllll” Q: JS 实现函数运行一秒后打印输出0-9;给定如下代码 for(var i=0;i&lt;10;i++){ // TODO} 解法 // 这道题涉及到作用域for(var i=0;i&lt;10;i++){ setTimeout((function(i){ return function(){ console.log(i); } })(i),1000);} 若是用到 ES6…那简直不能再简便了 for(let i=0;i&lt;10;i++){ setTimeout(function(){ console.log(i); },1000);} Q: 实现对一个数组或者对象的浅拷贝和”深度”拷贝 浅拷贝就是把属于源对象的值都复制一遍到新的对象,不会开辟两者独立的内存区域; 深度拷贝则是完完全全两个独立的内存区域,互不干扰 浅拷贝 // 这个 ES5的 function shallowClone(sourceObj) { // 先判断传入的是否为对象类型 if (!sourceObj || typeof sourceObj !== ‘object’) { console.log(‘您传入的不是对象!!’) } // 判断传入的 Obj是类型,然后给予对应的赋值 var targetObj = sourceObj.constructor === Array ? [] : {}; // 遍历所有 key for (var keys in sourceObj) { // 判断所有属于自身原型链上的 key,而非继承(上游 )那些 if (sourceObj.hasOwnProperty(keys)) { // 一一复制过来 targetObj[keys] = sourceObj[keys]; } } return targetObj;} // ES6 可以用 Object.assign(targeObj, source1,source2,source3) 来实现对象浅拷贝 深度拷贝 // 就是把需要赋值的类型转为基本类型(字符串这些)而非引用类型来实现// JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象 var deepClone = function(sourceObj) { if (!sourceObj || typeof sourceObj !== ‘object’) { console.log(‘您传入的不是对象!!’); return; } // 转-&gt;解析-&gt;返回一步到位 return window.JSON ? JSON.parse(JSON.stringify(sourceObj)) : console.log(‘您的浏览器不支持 JSON API’);}; 深拷贝的考虑点实际上要复杂的多,详情看看知乎怎么说Q: this对象的理解 简言之:谁调用指向谁,运行时的上下文确定,而非定义的时候就确定; 强行绑定 this的话,可以用 call,apply,bind,箭头函数….来修改this的指向 这类的文章太多,自行搜索吧…. Q: 看到你说到 bind,能用 JS简单的模拟个么? Function.prototype.emulateBind = function (context) { var self = this; return function () { return self.apply(context); } } 这个实现很粗糙…更为详细全面,考虑周全的(比如参数的处理什么的)…自行谷歌. Q:JS 的作用域是什么?有什么特别之处么? 作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些; 函数声明提升优于变量声明提升.. 作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的); 作用域会影响this的指向 坐等补充,我回答的时候,面试大佬只是 嗯..恩…恩…也不知道具体如何 Q: 怎么解决跨域问题,有哪些方法… 我一般用这三种,cors,nginx反向代理,jsonp jsonp : 单纯的 get 一些数据,局限性很大…就是利用script标签的src属性来实现跨域。nginx 反向代理: 主要就是用了nginx.conf内的proxy_pass http://xxx.xxx.xxx,会把所有请求代理到那个域名,有利也有弊吧..cors的话,可控性较强,需要前后端都设置,兼容性 IE10+ ,比如Access-Control-Allow-Origin: http://foo.example // 子域乃至整个域名或所有域名是否允许访问Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段Access-Control-Max-Age: 86400 // 有效期Q: 对于想携带一些鉴权信息跨域如何走起?比如cookie! 需要配置下 header Access-Control-Allow-Credentials:true ,具体用法看下面的nginxdemo 当然cros的配置不仅仅这些,还有其他一些,具体引擎吧…. 若是我们要用 nginx或者 express 配置cors应该怎么搞起? 来个简易版本的 nginxlocation / { 检查域名后缀add_header Access-Control-Allow-Origin xx.xx.com; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type; add_header Access-Control-Max-Age 86400; } express, 当然这货也有一些别人封装好的 cors中间件,操作性更强…let express = require(‘express’);let app = express(); //设置所有请求的头部app.all(‘*’, (req, res, next) =&gt; { res.header(“Access-Control-Allow-Origin”, “xx.xx.com”); res.header(“Access-Control-Allow-Headers”, “DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type”); res.header(“Access-Control-Allow-Credentials”,”true”) res.header(“Access-Control-Allow-Methods”,”PUT,POST,GET,DELETE,OPTIONS”); next();}); 有些还会跟你死磕,,除了这些还有其他姿势么…我说了一个HTML5的postMessage…. ..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下 这货用于iframe 传递消息居多, 大体有这么两步步 window打开一个实例,传递一个消息到一个x域名x 域名下监听message事件,获取传递的消息这货的兼容性没那么好,而且没考虑周全下容易遭受 CSRF 攻击 Q: 对于XSS 和 CSRF 如何防范 这里就不说概念性的东西了 XSS的防范 我能想到的就是转义&lt;&gt;这些造成代码直接运行的的标签..轮询或者正则替换而面试官说这种的效率最低下,我回来仔细找了找相关资料好像没有更优方案…有的留言…若是有用到 cookie,设置为http-only,避免客户端的篡改CSRF的防范一般这几种 验证码,用户体验虽然不好,,但是很多场合下可以防范大多数攻击验证 HTTP Referer 字段,判断请求来源token加密解密,这种是目前很常用的手段了…任何防范都有代价的,比如验证码造成的体验不好,token滥用造成的性能问题,轮询替换造成的响应时间等 Q: 描述下cookie,sessionStorage,localSotrage的差异.. cookie : 大小4KB 左右,跟随请求(请求头),会占用带宽资源,但是若是用来判断用户是否在线这些挺方便sessionStorage和localStorage大同小异,大小看浏览器支持,一般为5MB,数据只保留在本地,不参与服务端交互.sessionStorage的生存周期只限于会话中,关闭了储存的数据就没了.localStorage则保留在本地,没有人为清除会一直保留Q: javascript的原型链你怎么理解? 原型链算是 JS 内一种独有的机制, 所有对象都有一个内置[[proto]]指向创建它的原型对象(prototype) 原型链的基本用来实现继承用的 Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享 我在写的时候,用了两种,一个是 ES5和 ES6的方案 ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。 function ParentClass(name) { this.name = name; } ParentClass.prototype.sayHello = function () { console.log(&quot;I&apos;m parent!&quot; + this.name); } function SubClass(name, age) { //若是要多个参数可以用apply 结合 ...解构 ParentClass.call(this, name); this.age = age; } SubClass.prototype = Object.create(ParentClass.prototype); SubClass.prototype.constructor = SubClass; SubClass.prototype.sayChildHello = function (name) { console.log(&quot;I&apos;m child &quot; + this.name) } let testA = new SubClass(&apos;CRPER&apos;) // Object.create()的polyfill /* function pureObject(o){ //定义了一个临时构造函数 function F() {} //将这个临时构造函数的原型指向了传入进来的对象。 F.prototype = obj; //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。 //因为该实例的原型是obj对象。 return new F(); } */ ES6: 其实就是ES5的语法糖,不过可读性很强.. class ParentClass { constructor(name) { this.name = name; } sayHello() { console.log(“I’m parent!” + this.name); } } class SubClass extends ParentClass { constructor(name) { super(name); } sayChildHello() { console.log(&quot;I&apos;m child &quot; + this.name) } // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上 sayHello(){ console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;) } } let testA = new SubClass(&apos;CRPER&apos;) 到这里就结束了么…不,这只是笔试, Q: 问的时候你用过静态方法,静态属性,私有变量么? 静态方法是ES6之后才有这么个玩意,有这么些特点 方法不能给 this引用,可以给类直接引用静态不可以给实例调用,比如 let a = new ParentClass =&gt; a.sayHello() 会抛出异常父类静态方法,子类非static方法没法覆盖父类静态方法可以给子类继承静态属性可以继承也可以被修改看下面的代码.. class ParentClass { constructor(name) { this.name = name; } static sayHello() { console.log(“I’m parent!” + this.name); } static testFunc(){ console.log(&apos;emm...Parent test static Func&apos;) } } class SubClass extends ParentClass { constructor(name) { super(name); } sayChildHello() { console.log(&quot;I&apos;m child &quot; + this.name) } static sayHello() { console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;) } static testFunc2() { console.log(super.testFunc() + &apos;fsdafasdf&apos;); } } ParentClass.sayHello(); // success print let a = new ParentClass(&apos;test&apos;); a.sayHello() // throw error SubClass.sayHello(); // 同名 static 可以继承且覆盖 SubClass.testFunc2(); // 可以继承 let testA = new SubClass(&apos;CRPER&apos;); 私有变量这个我没答出来,只是说了下没有private这个关键字和基本用下划线的人为区分 所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是WeakMap; WeakMap可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了. const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了 class TestWeakMap { constructor(id, barcode) { _.set(this, { id,barcode }); } testFunc() { let { id,barcode } = _.get(this); // 获取对应的值 return { id,barcode }; }} Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么? Promise和ajax没有半毛钱直接关系.promise只是为了解决”回调地狱”而诞生的; 平时结合 ajax是为了更好的梳理和控制流程…这里我们简单梳理下.. Promise有三种状态,Pending/resolve()/reject(); 一些需要注意的小点,如下 在 Pending 转为另外两种之一的状态时候,状态不可在改变..Promise的 then为异步.而(new Promise())构造函数内为同步Promise的catch不能捕获任意情况的错误(比如 then 里面的setTimout内手动抛出一个Error)Promise的then返回Promise.reject()会中断链式调用Promise的 resolve若是传入值而非函数,会发生值穿透的现象Promise的catch还是then,return的都是一个新的 Promise(在 Promise 没有被中断的情况下)Promise 还有一些自带的方法,比如race,all,前者有任一一个解析完毕就返回,后者所有解析完毕返回… 实现一个延时的 promise 函数, 可以用async和await const delay = (time)=&gt; new Promise((resolve,reject)=&gt;{ setTimeout(resolve,time)}) // test let testRun = async function(){ console.log(1); await delay(2000); console.log(‘我两秒后才触发’,3)} // 1 =&gt; Promise = &gt; 3 这段代码的运行结果是什么? var test = new Promise((resolve,reject)=&gt;{ resolve();}); test .then(data =&gt; { // promise start console.log(‘promise first then : ‘, data); return Promise.resolve(1); // p1 }) .then(data =&gt; { // promise p1 console.log(‘get parent(p1) resolve data : ‘, data); return Promise.reject(new Error(‘哎呀,中断了,你能奈我何!’)); // p2 }) .then(data =&gt; { // promise p2 console.log(‘result of p2: ‘, data); return Promise.resolve(3); // p3 }) .catch(err =&gt; { console.log(‘err: ‘, err); return false; }); // promise first then : undefined// get parent(p1) resolve data : 1// err: Error: 哎呀,中断了,你能奈我何! // 这里在 then 返回 Promise.reject()的时候已经中断了链式调用.直接给 catch捕获到 别急,假如你不管有没有捕获到错误,最后再执行一个回调函数如何实现? 这里说的就是类似try..catch..finally,给Promise实现一个 finally; // finally比较好加，按照现在社区的讨论，finally的特点如下：// url : https://www.v2ex.com/t/205715//1. 不接收任何参数，原来的value或者Error在finally里是收不到的//2. 处理后不影响原Promise的状态，该reject还是reject，该resolve还是resolve//3. 不影响Promise向后传递的传，resolve状态还是传递原来的value，reject状态还是传递原来的Error Promise.prototype.finally = function (callback) { let P = this.constructor; // 这里拿到的是 Promise 的构造函数 //不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) );}; // 用法很简单,就是可以传入一个回调函数..// https://developers.google.com/web/updates/2017/10/promise-finally// 这个 url 中说了 node 及 chrome 的哪些版本已经实现了 finally 及用法// ES 2018已经把 finally 追加到 promise 的原型链中.. &lt;&gt;: 有助于你更加深刻的了解 promise 的运行情况关于 Promise 的 9 个提示更多的Promise 详情可以参考&lt;&gt;;Q: 谈谈你对 TCP 的理解; Q: TCP 是在哪个OSI 的哪个层!通讯过程是全双工还是半双工(单工)? A: 传输层,全双工 Q: TCP的通讯的过程是怎么样的! A: 整个过程是三次握手,四次挥手.. Q: 你说的没错,说说整个过程如何? A: 举个栗子,我把 TCP 比做两个人用对讲机沟通(大白话)..三次握手就是.A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端).. A1对着对讲机说”over over ,听到请回答”(第一次,请求应答) … A2收到回应”收到收到,你说”(第二次,确认应答) A1开始巴拉巴拉个不停而 A2没拒绝(第三次,通讯建立) 而四次挥手则是两者确认互相倾述完毕的过程.. A1说:”控制室,报告完毕了”(第一次挥手) A2说:”知道了…那么你废话说完就好好听我指挥….巴拉巴拉..”(第二次挥手) A1此时等待控制室说完毕,而控制室等回应(第三次挥手) 等到 A1回馈控制室确认都知道完毕了..(第四次挥手)… 以上都是瞎掰,可能有些地方描述不当,笑笑就好了 TCP没有百分百建立成功的,会造成链接失败的情况有很多.. 比如长时间没应答(A1吼了半天没有反应或者 A2应答了而 A1不再鸟它)..亦或者丢包(对讲机也没了); TCP 协议相关的文章网上很多,若是要更加全面的了解该协议请自行引擎.. 我建议阅读&lt;&lt;TCP-IP详解卷1~卷3&gt;&gt;,这个是网络圣经…很厚…我只看了一丢丢.. Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧? 对于这类的问题我也只能大体点了下,毕竟不是专攻网络这块的… OSI 七层涵盖:物理层,数据链路层,网络层,传输层,会话层,表示层,应用层; 五层模型就是”会话,表示,应用层”同为一层; Q: DNS 的大体的执行流程了解么,属于哪个层级?工作在哪个层级? DNS 属于应用层协议, 至于TCP/UDP哪一层上面跑,看情况 , 大体的执行流程是这样的; 优先读取浏览器缓存其次系统的缓存都没有的情况下,找本地hosts文件(比如你写了映射关系优先寻找)再没有的情况找最近的域名解析服务器再没有则扩大访问,最终找到根服务器,还是没有就失败了..DNS 的解析的几个记录类型需要了解: A: 域名直接到 IPCNAME: 可以多个域名映射到一个主机,类似在 Github Page就用 CNAME 指向MX: 邮件交换记录,用的不多,一般搭建邮件服务器才会用到NS: 解析服务记录,可以设置权重,指定谁解析TTL: 就是生存时间(也叫缓存时间),一般的域名解析商都有默认值,也可以人为设置TXT: 一般指某个主机名或域名的说明回来我找下相关的资料,有兴趣的可以深入了解下,传送门如下: 梳理Linux下OSI七层网络与TCP/IP五层网络架构TCP/IP（六）应用层（DNS和HTTP协议）DNS域名解析解剖Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么? 我只是粗浅的回答了下… HTTP相对于 HTTPS来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是80端口; HTTP容易遭受域名劫持,而HTTPS相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为443.. HTTP是明文跑在 TCP 上.而HTTPS跑在SSL/TLS应用层之下,TCP上的 Q: 那么 HTTPS中的TLS/SSL是如何保护数据的… 一般有两种形式,非对称加密,生成公钥和私钥,私钥丢服务器,公钥每次请求去比对验证; 更严谨的采用 CA(Certificate Authority),给密钥签名…. Q: 你说到对称加密和非对称加密,能说说整个流程如何运转的么(HTTPS) 对称加密:双方都有同样的密钥,每次通讯都要生成一个唯一密钥,速度很快安全性较低且密钥增长的数量极快非对称加密(一般用 RSA)安全性很高,对资源消耗很大(CPU),目前主流的加密算法(基本用于交换密钥或签名,而非所有通讯内容)CA(数字签名):这个是为了防止中间人给偷换了造成数据被窃取而诞生的用一些权威机构颁布的算法来签名,权威机构做中间人,通讯过程都会跟机构核对一遍懂得真心不多,回来找了下相关资料,有兴趣可以点击看看; 深入揭秘HTTPS安全问题&amp;连接建立全过程深入理解 https 通信加密过程:口语化 “ : 看了上面那篇文章来看下面,会清晰很多Q: SPDY 听说过么.什么来的? 谷歌推行一种协议(HTTP 之下SSL之上[TCP]),可以算是HTTP2的前身,有这么些优点 压缩数据(HEADER)多路复用优先级(可以给请求设置优先级)而这些优点基本 HTTP2也继承下来了.. Q: 你对 HTTP 的状态吗了解多少… 这里列举一丢丢常见的.. 1XX: 一般用来判断协议更换或者确认服务端收到请求这些100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容101: 客户端请求变换协议,服务端收到确认2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些200: (成功)服务器已成功处理了请求。201: (已创建)请求成功并且服务器创建了新的资源。202: (已接受)服务器已接受请求，但尚未处理。204: (无内容)服务器成功处理了请求，但没有返回任何内容。3XX: 一般用来判断重定向和缓存301: 所有请求已经转移到新的 url(永久重定向),会被缓存302: 临时重定向,不会被缓存304: 本地资源暂未改动,优先使用本地的(根据If-Modified-Since or If-Match去比对服务器的资源,缓存)4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失400: 请求出错401: 未授权,不能读取某些资源403: 阻止访问,一般也是权限问题404: 页面丢失,资源没找到408: 请求超时415: 媒介类型不被支持，服务器不会接受请求。5XX: 基本都是服务端的错误500: 服务端错误502: 网关错误504: 网关超时Q: HTTP的请求报文是怎么样的,能大体的说下么? HTTP 的请求报文 = 请求行 + 请求头 + 请求体; 请求行: 这个好理解就是访问的方法+ 协议+ 访问的 URL 构成请求头: 这个也好理解,比如 accept,content-type,user-agent这类值键对,服务端可以直接读取的请求体: 比如 POST 提交的一个表单,我们编码后放在上面需要传递的想深入了解的具体引擎搜索 Q: 请求报文知道,那你说说cookie是如何跟随请求的? Cookie 就是保存在 HTTP 协议的请求或者应答头部(Cookie 是由服务端生成),这样一路漂泊… Q: Cookie 隔离是什么,如何做; cookie 隔离就是降低 header 的数据包含,以达到加快访问速度的目的 方案: 静态资源丢 CDN或者非主域来加载 Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看? Last-Modified:第一次请求资源从服务器拉取的会自动带上该属性第二次请求会跟服务端比对If-Modified-Since的时间,没变动则使用本地的(状态304)结合Expires(过期时间:缓存的载止时间),跟随请求一起发出..资源没过期拿本地,否则重新请求Cache-control 是 HTTP1.1的东西,判断资源过期结合max-age来替代Expires[http 1.0]Etag:第一次请求url 时候会给服务器上标记(一串字符串)第二次请求时候会比对服务端的If-None-Match,没有改动依旧拿缓存(304)Q: 几个短而让我印象深刻的题 if(!(“a” in window)){ var a = 10;}console.log(a); // undefined // !(“a” i n window) , 返回 true// 留言小伙伴的刨析,非常感谢,还是涉及变量提升的问题/ var a;if(!(“a” in window)){ a = 10;} / // 变种题(function(){ var x = c = b = {a:1}})() console.log(x.a); // error , x is not definedconsole.log(c,b) // {a: 1} {a: 1} var count = 0; console.log(typeof count === “number”); // true , 这个不用解释了 console.log(!!typeof count === “number”); // false // 这里涉及到就是优先级和布尔值的问题// typeof count 就是字符串”number”// !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true// 最后才=== 比较 , true === “number” , return false (function(){ var a = b = 3;})() console.log(typeof a === “undefined”); // trueconsole.log(typeof b === “undefined”); // false // 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(=号自左向右)// 那个函数可以拆成这样 (function() var a; / 局部变量,外部没法访问/ b = 3; / 全局变量,so . window.b === 3 , 外部可以访问到/ a = b;})() // 若是改成这样,这道题应该是对的console.log(typeof b === “number” &amp;&amp; b ===3); // true function foo(something){ this.a = something;} var obj1 = { foo:foo}; var obj2 = {}; obj1.foo(2) console.log(obj1.a) // 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window obj1.foo.call(obj2,3); // 用 call 强行改变上下文为 obj2内console.log(obj2.a); // 3 var bar = new obj1.foo(4); // 这里产生了一个实例console.log(obj1.a); // 2console.log(bar.a); // 4; new的绑定比隐式和显式绑定优先级更高 function fn(){ alert(a); var a = 200; alert(a);} fn(); // undefined / 200 ; 涉及变量提升alert(a); // undefinedvar a;alert(a); // undefined var a = 300;alert(a); // 300 var obj1= { name:’obj1’, fn:function(){ console.log(this.name); }}; var obj2 = {name:’obj2’};var obj3 = {name:’obj3’}; // 这道题主要涉及的是 this 指向的问题..obj1.fn(); // obj1 var newFn = obj1.fn;newFn(); // undefined, this 指向 window newFn.call(obj2);// obj2, this 指向 obj2 obj3.fn = newFn;/ƒ (){ console.log(this.name); } / obj3.fn(); // 这里指向的是 obj3 .所以输出 obj3 // 这道题来作为笔试题很绕,因为要回答的答案很多(脑海构思)..反正我是遇到了..// 这道题主要考核的是对原型链继承这块的理解function Parent(){ this.a = 1; this.b = [1,2,this.a]; this.c = {demo:5}; this.show = function(){ console.log(this.a + ‘’ + this.c.demo + ‘:’ + this.b) }} function Child(){ this.a = 2; this.change = function(){ this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; } } Child.prototype = new Parent();var parent = new Parent();var child1 = new Child();var child2 = new Child(); child1.a = 11;child2.a = 12; // 这前面几个还算简单,继续看下去parent.show(); // 15:1,2,1 // 因为 Child 自身没有 show 的方法,所以往原型链的上游找;// 找到父类的,this 因为没更改,所以输出结果如下child1.show(); // 115:1,2,1child2.show(); // 125:1,2,1 child1.change(); // 改变一些数据,没有输出child2.change(); // +1 parent.show(); // 15:1,2,1 child1.show(); // 55:1,2,1,11,12child2.show(); // 65:1,2,1,11,12 // 这道题也很绕,函数递归调用的 function test(a,b){ console.log(b); return { test:function(c){ return test(c,a); }}; // 这道题的理解,拆成这样就好理解了/*function test(a,b){ console.log(“a:”+a,”b:”+b); return { test:function(c){ console.log(“a:”+a,”b:”+b,”c”+c); return test(c,a); } } }*/ var a = test(100); // undefined, 这个是不言而喻的;a.test(200); // 100;a.test(300); // 100; var b = test(101).test(201).test(301); // undefined/101/201 var c = test(102).test(202); // undefined / 102 c.test(302); // 202 Q:有字符串 var test=’abc345efgabcab’; 请根据提示实现对应要求 去掉字符串中的 a,b,c 字符 ,形成结果’345efg’; test.replace(/[abc]/g,’’); // “345efg” 将字符串的数字用括号括起来, 形成结果: abc[3][4][5]efg….’ test.replace(/\d/g,’[$&amp;]’); // “abc[3][4][5]efgabcab” // 若是有分组则按照$1, $2, $3的形式进行引用，而 $&amp; 则表示的是整个正则表达式匹配的内容。 将字符串中的每个数字的值分别乘以2,输出:’abc6810….’ var temp = test.split(‘’).map(function(item){ return /^\d$/.test(item) ? item * 2 : item;}).join(‘’); // “abc6810efgabcab” Q: 使用不少于三种方式替换文本”dream”改成”package”,提供字符串”I have a dream”; 正则替换// 这是最简单的代码量了..var str = “I have a dream”;str.replace(/dream/g,”package”); // 不用正则也可以直接字符串替换str.replace(“dream”,”package”) 数组遍历更改// 很直白的大脑回路var str = “I have a dream”; str.split(“ “).map(function(item){ return item === “dream” ? item = “package”:item;}).join(“ “); 数组查询切割法var str = “I have a dream”; var tempArr = str.split(“ “); // [“I”, “have”, “a”, “dream”]var removeIndex = tempArr.indexOf(‘dream’); // 3 tempArr.splice(removeIndex,1,”package”); var transStr = tempArr.join(“ “); // “I have a package”; 这类东东弄成数组还是挺好弄的 Q: 还有一道题目是涉及事件循环,执行优先权的.. 就是 macrotask和microtask 相关的, 具体记不起来了..那时候给了答案虽然对了. 要说出所以然,给秀了一脸..回来找了下相关的资料; JavaScript 运行机制详解：再谈Event Loop深入理解事件循环和异步流程控制所有你需要知道的关于完全理解 Node.js 事件循环及其度量Q: 你对基础算法这块掌握的如何…. 来,这纸给你,写个快排试试… // 快排的大体思路是这样的,// 找个中位值,从原数组切割出来,// 剩下的作为两个数组,每次都去比较;// 直到递归的结果出来, 平均复杂度O(nlog n) function quickSort(arr) { //如果数组长度&lt;=1,则直接返回 if (arr.length &lt;= 1) { return arr; } // 中间位(基准)取长度的一半向下取整 var pivotIndex = Math.floor(arr.length / 2); //把中间位从原数组切割出来, splice 会改变原数组!!!! var pivot = arr.splice(pivotIndex, 1)[0]; //定义两个空数组来存放比对后的值 var left = []; var right = []; //比基准小的放在left，比基准大的放在right for (var i = 0 , j = arr.length; i &lt; j; i++) { if (arr[i] &lt;= pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } //递归下去 arr = [ left , pivot , right] // 怎么个递归法,就是比对后的数组还是会重复之前的取基准再切开比较..直到最后没有可以切了 return quickSort(left).concat([pivot], quickSort(right));} Q: 写一个二分法查找 // 二分法跟快排的思路差不多,对半比较// 这个只用于排序好数组内的查询,高低位都知道的情况下function binSearch(target, arr, start, end) { var start = start || 0; // 允许从什么位置开始,下标 var end = end || arr.length - 1; // 什么位置结束,下标 start &gt;= end ? -1 : ‘’; // 没有找到,直接返回-1 var mid = Math.floor((start + end) / 2); // 中位下标 if (target == arr[mid]) { return mid; // 找到直接返回下标 } else if (target &gt; arr[mid]) { //目标值若是大于中位值,则下标往前走一位 return binSearch(target, arr, start, mid - 1); } else { //若是目标值小于中位值,则下标往后退一位 return binSearch(target, arr, mid + 1, end); }} // binSearch(5,[1,2,3,4,5,6,7,8]) =&gt; 4 // 无序的数组则需要先排序好数组,否则会堆栈溢出(死循环) 这类的文章很多,有兴趣的可以阅读下面的一些文章 传送门: &lt;&lt;十大经典排序算法总结（JavaScript描述&gt;&gt;JavaScript数据结构和算法javascript 常见排序算法Q: 设计模式你了解多少? Javascript常用的设计模式详解js-design-patternQ: 思维拓展题: 你有两个玻璃球,有个100米的高楼,求玻璃球在哪个楼层扔下会碎(用的次数最少); 问题的要点: 玻璃球碎(有限个数) ,确定楼层数 , 最少次数 =&gt; 就是求最优的公式 在这道题上给秀的一脸,我的第一次的思路 先折半,就变成[1-50][51-100], 那就是 1+50 = 51次 … 面试大佬说,你用了快排的思路就肯定不是最优的.. 憋了许久,想到开平方 \sqrt[2]{100} , 这样的话,最多只要20次 然后又说给我三个球,在1000米的高楼,判断多少次…但是根据我上面的话, 开立方, \sqrt[3]{1000} , 那最多不超过30次; 至于第一次丢球的位置如何确定, 就是开平之后的值作为一个区间. 若 N 个球和 M 米的大厦…第一次丢球的高度区间就是这个了\frac{m}{\sqrt[n]{m}} 面试大佬说这个还可以…那就暂且告一段落 …回来用万能的搜索引擎找了下..最优方案+最少次数需要考虑的东西很多,没那么简单 传送门: 知乎有人讨论了这个问题; 但是高数还老师了..这种帖子看的一脸懵逼….抽空再好好研究下 Q: 你对优化这块了解多少? 大体常见的手段了解. 比如从客户端着手的: 压缩代码(JS/CSS),压缩图片合并一些小图片(css sprite)若是打包的代码尽可能切割成多个 chunk,减少单一 chunk过大静态文件采用 cdn 引入HTTP的缓存头使用的合理减小第三方库的依赖对于代码应该考虑性能来编写,比如使用requestAnimationFrame绘制动画,尽可能减少页面重绘(DOM 改变)渐进升级,引入preload这些预加载资源看情况用service worker来缓存资源(比如移动端打算搞 PWA)比如从服务端着手: 带宽,域名解析, 多域名解析等页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)当然,这是这些都是很片面的点到…实际工作中去开展要复杂的多; 比如我们要多个维度去考虑的话,要去优化 DOM 的绘制时间,资源的加载时间,域名解析这些; 要全面的优化一个项目是一个大工程… Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异 MySQL索引类型: 普通索引: 就普通的类型唯一索引: 代表索引的值唯一不重复(允许有空值),相对于上面多了个UNIQUE主键索引:(创建表的跟随创建,唯一索引，不允许有空值)组合索引(就是将多个字段都建立到一个索引)索引有利有弊,用的好加快查询速度,滥用索引会造成大量磁盘空间占用,维护性也会增多; 索引不会包含null的列; 索引的数据结构储存方式,我只简单了解过B-Tree 至于MySQL 和 MongoDB的差异; 前者是关系型数据库, 后者非关系型数据库(数据是以文档的方式储存,值为 key-value); MySQL应用层面很广,有事务系统这些,链表查询这些都很方便.经常作为很多系统的主力数据库 而MongoDB作为NoSQL,虽然有些层面不如 MySQL,但是应用层面也挺广, 比如结合前端做一些用户的概要信息的维护,一些缓存信息的维护. em….后端了解不多,也能点到即止….大学的时候学过一些..都差不多还给老师…. Q: JS时间分段 给定一个时间段和步长，枚举该时间段内步长的划分 例如：时间段3:00-5:00，步长为20分钟 那么返回的数组为 [‘3:00-3:20’, ‘3:20-3:40’….]等 这类问题,一般都要先梳理好思路再来写; 给定字符串时间段,切割,转换为分钟跨日及跨时问题 // 这个东东我的小伙伴也写出来了.我的是在它的解答方式上加以注释和对参数的判断做了考虑// 他的解法方案在他的 github 上 https://github.com/lyh2668/blog/issues/1 , by lyh2668// 方便一些小伙伴的理解,以下代码包含ES6的姿势(参数默认值,剪头函数) let inputDateRange = (date, step = 30, separator = ‘-‘) =&gt; { let startTime, endTime; // 开始时间和结束时间 if (Object.prototype.toString.call(date) === ‘[object String]’) { date = date.trim(); // 去除两边的空格 var tempDate = ‘’; if (separator) { tempDate = date.split(separator); } else { if (date.indexOf(‘-‘) !== -1) { tempDate = date.split(‘-‘); } else if (date.indexOf(‘~’)) { tempDate = date.split(‘~’); } else { console.log(‘您传入的也许不是一个时间段!!!’); } } startTime = time2min(tempDate[0]); // 传入的开始时间 endTime = time2min(tempDate[1]); //传入的结束时间 } else if (Object.prototype.toString.call(date) === ‘[object Array]’) { if (date.length === 2) { startTime = time2min(date[0]); // 传入的开始时间 endTime = time2min(date[1]); //传入的结束时间 } } else { console.log(‘您传入的也许不是一个时间段!!!’); } // 传入的 step 是否为数字,否则截图数字部分转化 // 为什么和 NaN 比较(自身不等性),若是传入的连正则都没法识别,那只能给默认值了 Object.prototype.toString.call(step) === ‘[object Number]’ ? (step = parseInt(step, 10)) : parseInt(step.replace(/[W\s\b]/g, ‘’), 10) === NaN ? (step = parseInt(step.replace(/[W\s\b]/g, ‘’), 10)) : (step = 30); // 若是开始时间大于结束时间则结束时间往后追加一天 startTime &gt; endTime ? (endTime += 24 * 60) : ‘’; let transformDate = []; // 储存转换后的数组,时间分段 // 开始遍历判断,用 while while (startTime &lt; endTime) { // 如果开始时间+步长大于结束时间,则这个分段结束,否则结束时间是步长递增 let right = startTime + step &gt; endTime ? endTime : startTime + step; transformDate.push(${min2time(startTime)}-${min2time(right)}); startTime += step; // 步长递增 } return transformDate;}; // 时间转化为分钟let time2min = time =&gt; { // 获取切割的 time.indexOf(‘:’) ? (time = time.trim().split(‘:’)) : ‘’; return time[0] * 60 + parseInt(time[1]); // 返回转化的分钟}; // 分钟转会字符串时间let min2time = minutes =&gt; { let hour = parseInt(minutes / 60); // 返回多少小时 let minute = minutes - hour * 60; // 扣除小时后剩余的分钟数 hour &gt;= 24 ? (hour = hour - 24) : ‘’; // 若是大于等于24小时需要扣除一天得到所剩下的小时 minute &lt; 10 ? (minute = ‘0’ + minute) : ‘’; // 小于10的都要补零 hour &lt; 10 ? (hour = ‘0’ + hour) : ‘’; // 小于10的都要补零 return ${hour}:${minute};}; // test ,支持字符串传入时间段inputDateRange(‘3:00-5:00’,’20d’); // [“03:00-03:20”, “03:20-03:40”, “03:40-04:00”, “04:00-04:20”, “04:20-04:40”, “04:40-05:00”] // 亦或者数组传入inputDateRange([‘3:00’,’5:00’],’45df.3d’); // [“03:00-03:45”, “03:45-04:30”, “04:30-05:00”] // step 支持数字亦或者带特殊字符的数字inputDateRange([‘6:00’,’8:00’],’55df.3d’); // [“06:00-06:55”, “06:55-07:50”, “07:50-08:00”] inputDateRange(‘3:00-5:00’,60); // [“03:00-04:00”, “04:00-05:00”] JS不靠谱系列之枚举出时间段和对应的分钟数Q: Vue-Router的两种模式主要依赖什么实现的 hash主要依赖location.hash来改动 URL,达到不刷新跳转的效果.每次 hash 改变都会触发hashchange事件(来响应路由的变化,比如页面的更换)history主要利用了 HTML5的 historyAPI 来实现,用pushState和replaceState来操作浏览历史记录栈Q: MVVM 和 MVC 的差异? 听说过 MVP? 这类的文章好多,三个开发模式的诞生都有前后,不是同时出现的. 传送门: MVC，MVP 和 MVVM 的图示浅析前端开发中的 MVC/MVP/MVVM 模式Q: 求100~999的所有”水仙花”数, 就是三位数中各数字的立方和等于自身,比如153=1^3+5^3+3^3 常规遍历法function threeWaterFlower(rangeStart, rangeEnd) { var temp = []; rangeStart = rangeStart || 100; rangeEnd = rangeEnd || 999; for (var i = rangeStart; i &lt;= rangeEnd; i++) { var t = i.toString().split(‘’); Math.pow(t[0], 3) + Math.pow(t[1], 3) + Math.pow(t[2], 3) == i ? temp.push(i) : ‘’; } return temp;} threeWaterFlower(100,999); // [153, 370, 371, 407] threeWaterFlower(); // [153, 370, 371, 407] 拓展写法,ES6版+不定花数,不折腾不舒服版本 let manyWaterFlower = (rangeStart = 100, rangeEnd = 999, flower = 3) =&gt; { let temp = []; for (let i = rangeStart; i &lt;= rangeEnd; i++) { let t = i .toString() .split(‘’) .map(item =&gt; Math.pow(item, flower)) .reduce((cur,next)=&gt; parseInt(cur)+parseInt(next)); let transformT = parseInt(t, 10); transformT == i ? temp.push(i) : ‘’; } return temp;} manyWaterFlower(); // [153, 370, 371, 407] manyWaterFlower(100,10000,4); // [1634, 8208, 9474] manyWaterFlower(100,10000,5); // [4150, 4151] 这种是穷举遍历,若是要快一点呢(考虑的周全一点呢),以及传参范围的矫正 相信小伙伴都看得懂,我已经尽量注释了.. let manyWaterFlower = (flower = 3,rangeStart, rangeEnd ) =&gt; { let temp = [];// 缓存所有找到的花值 // 这一段就是填充开始循环的范围,处理完毕后转为数字,推荐的开始值 let flowerRecommandStart = Number( ‘’.padStart(flower, ‘0’).replace(/^(\d{1})/g, ‘1’) ); let flowerRecommandEnd = Number(‘’.padStart(flower, ‘9’)); // 判断是否传入开始值 if (rangeStart) { rangeStart &gt; flowerRecommandStart ? (rangeStart = flowerRecommandStart) : rangeStart; } else { rangeStart = flowerRecommandStart; } // 判断是否有传入结束值 if (rangeEnd) { rangeEnd &gt; flowerRecommandEnd ? (rangeEnd = flowerRecommandEnd) : rangeEnd; } else { rangeEnd = flowerRecommandEnd; } // 若是初始值大于结束值 if (rangeStart &gt; rangeEnd) { rangeEnd = flowerRecommandEnd; } for (let i = rangeStart; i &lt;= rangeEnd; i++) { let t = i .toString() .split(‘’) .map(item =&gt; Math.pow(item, flower)) .reduce((cur, next) =&gt; parseInt(cur) + parseInt(next)); let transformT = parseInt(t, 10); transformT == i ? temp.push(i) : ‘’; } return temp;}; console.time(‘manyWaterFlower’);manyWaterFlower(4)console.timeEnd(‘manyWaterFlower’);// VM34013:4 manyWaterFlower: 8.112060546875ms ,这个是跑出来的时间 用上个例子的代码,从100到9999的,我们跑一下看看console.time(‘manyWaterFlower’);manyWaterFlower(100,9999,4)console.timeEnd(‘manyWaterFlower’);// VM3135:4 manyWaterFlower: 10.51904296875ms // 我的 MBP 跑10花直接卡死…跑7花有点久…console.time(‘7 flower’)manyWaterFlower(7);console.timeEnd(‘7 flower’)// 7 flower: 6489.608154296875ms // 8 花 CPU 的风扇狂叫….console.time(‘8 flower’)manyWaterFlower(8);console.timeEnd(‘8 flower’)// VM644:3 8 flower: 68010.26489257812ms // 对了我们还没有考虑数值溢出的问题..因为正整数在 JS 的范围是有限的.// 有兴趣的小伙伴可以自行完善 Q: 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值 比如console.log(findNode([‘a1’, ‘b2’], data)) === data.a1.b2 // 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值 var data = { a1: { b1: 1, b2: 2, b3: { b4: 5 } }, a2: { b1: 3, b2: 4 }}; function findNode(inPath, inData) { // TODO // 判断传入的是否是一个数组 if (Array.isArray(inPath)) { // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1 if (inPath.length === 1) { return inData[inPath[0]] ? inData[inPath[0]]: -1; }else{ return findNode(inPath.slice(1), inData[inPath[0]]); } } else{ console.log(‘您传入的不是一个数组’) }} console.log(findNode([‘a1’, ‘b2’], data)); // 2console.log(findNode([‘a1’, ‘b3’,’b4’], data)); // 5 来个拓展版?支持字符串或数组传入;findNode(‘a1,b2’,data)?// 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值 var data = { a1: { b1: 1, b2: 2, b3: { b4: 5 } }, a2: { b1: 3, b2: 4 }}; // 判断格式function isType(params) { let type = Object.prototype.toString.call(params); if (type === ‘[object String]’) { params = params.split(‘.’); return params; } if (type === ‘[object Array]’) { return params; }} function findNode(inPath, inData) { inPath = isType(inPath); // 判断传入的是否是一个数组 if (Array.isArray(inPath)) { // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1 if (inPath.length === 1) { return inData[inPath[0]] ? inData[inPath[0]] : -1; } for (var i = 0; i &lt; inPath.length; i++) { return findNode(inPath.slice(i + 1), inData[inPath[i]]); } } else { console.log(‘您传入的不是一个数组’); }} console.log(findNode([‘a1’, ‘b2’], data)); // 2 console.log(findNode(‘a1.b3.b4’, data)); // 5 Q: webpack 是什么?webpack 常见的优化手段有哪些; webpack 是一个资源处理工具,它的出现节省了我们的人力和时间; 可以对资源打包,解析,区分开发模式等等… 常见的优化手段: 分离第三方库(依赖),比如引入dll引入多进程编译,比如happypack提取公共的依赖模块,比如commonChunkPlugin资源混淆和压缩:比如UglifyJS分离样式这些,减小bundle chunk的大小,比如ExtractTextPluginGZIP 压缩,在打包的时候对资源对齐压缩,只要部署的服务器能解析即可..减少请求的大小还有按需加载这些,一般主流的框架都有对应的模块懒加载方式.至于tree shaking目前webpack3/4已经默认集成Q: 从你输入一个 URL 到页面渲染的大体过程… 大体过程是这样的,想了解很细致的可以自行引擎; IP-&gt;DNS(浏览器=&gt;系统缓存=&gt;DNS 服务器)-&gt;域名解析完成(这一步不用太多解析吧)TCP 协议走完-&gt;HTTP(S) 协议(分析请求头)-&gt; 回馈报文请求文档下来-&gt;DOM-&gt;CSSDOM-&gt;静态资源下载-&gt;render(绘制文档)-&gt;js 解析用户看到页面结语还有一些题目记不起来了,就没辙了…还有一些题目是看你个人发挥的,没法写,比如 Q: 让你来为公司的一个项目做技术选型,你会怎么做,为什么?Q: React,Angular,Vue的比较?Q: 说说你对 VNode的理解,diff的过程;Q: 小程序以及React Native的差异..等等]]></content>
      <categories>
        <category>前端</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载，面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack学习]]></title>
    <url>%2F2018%2F03%2F22%2Fwebpack%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是WebpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 webpack学习什么是webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 安装webpack1.建立文件夹，在当前文件夹执行命令1npm install -g webpack 由于安装后是4.0，需要安装webpack-cli，我安装的是3.6.0的，命令是 1npm install -g webpack@3.6.0 2.安装完成后输入npm init 会生成package.json文件中间会有提示，没有特殊需要回车即可。然后输入 1npm i -D webpack // -D 为--save-dev的简写 3.webpack -v 查看版本，如果失败输入1npm uninstall -g webpack 配置出入口文件首先了解下，webpack有4个核心概念 入口(entry) 输出(output) loader 插件(plugins) 1.建立webpack.config.js配置文件123456789101112moudle.exports=&#123; //入口文件配置 entry:&#123;&#125;, //出口文件配置 output:&#123;&#125;, //模块，解析cssjs，html以及扩展语言等 module:&#123;&#125;, //插件 plugins:[], //服务功能 devServer:&#123;&#125;&#125; 2.配置entry选项(入口配置)* 单入口文件12345//入口文件的配置项entry:&#123; //里面的entery是可以随便写的 index:&apos;./src/index.js&apos;&#125;, 多入口文件123456//入口文件的配置项entry:&#123; //里面的entery是可以随便写的 index1:&apos;./src/index1.js&apos; index2:&apos;./src/index2.js&apos;&#125;, 3.配置出口文件首先在最新版本中定义 1const path = require(&apos;path&apos;) 一般出口文件 123456output:&#123; //打包的路径,其中path.resolve(__dirname,&apos;dist&apos;)就是获取了项目的绝对路径 path: path.resolve(_dirname,&apos;dist&apos;), //打包以后的名称 filename: &apos;dist.js&apos;&#125; 多出口文件 1234567//出口文件的配置项 output:&#123; //输出的路径，用了Node语法 path:path.resolve(__dirname,&apos;dist&apos;), //输出的文件名称[name]就是根据入口文件命名的 filename:&apos;[name].js&apos; &#125;, 总结在配置webpack中必须使用require语法，否则会报错完成以后的代码 1234567891011121314151617181920cost webpack = require(&apos;webpack&apos;);const path = require(&apos;path&apos;);moudle.exports=&#123; //入口文件配置 entry:&#123; index1:&apos;./src/index1.js&apos; index2:&apos;./src/index2.js&apos; &#125;, //出口文件配置 output:&#123; path:path.resolve(__dirname,&apos;dist&apos;), filename:&apos;js/[name].js&apos; &#125;, //模块，解析cssjs，html以及扩展语言等 module:&#123;&#125;, //插件 plugins:[], //服务功能 devServer:&#123;&#125;&#125; 4.配置服务和热更新首先需要安装webpack-dev-server1npm i --save-dev webpack-dev-server 配置webpack.config.js文件12345678910devServer:&#123; //设置基本目录结构 contentBase:path.resolve(__dirname,&apos;dist&apos;), //服务器的IP地址，可以使用IP也可以使用localhost host:&apos;192.168.2.175&apos;, //服务端压缩是否开启 compress:true, //配置服务端口号 port:5050&#125; contentBase:配置服务器基本运行路径，用于找到程序打包地址。 host：服务运行地址，建议使用本机IP compress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习。 port：服务运行端口，建议不使用80，很容易被占用，这里使用了5050. 完成上述步骤，就可执行webpack-dev-server,如果出现1webpack-dev-server : 无法将webpack-dev-server 识别为cmdlet、函数、脚本文件或可运行程序入境... 在package.json中设置 123&quot;scripts&quot;: &#123; &quot;server&quot;:&quot;webpack-dev-server&quot; &#125;, 完成后执行++npm run server++ 即可 配置模块1.css模块1.先建立一个index.css将文件引入到index.js 1import css form &apos;./css/index.css&apos; 2.安装style-loader 和 css-loader 12345// 用来处理css中的url文件npm install style-loader --save-dev// 它是用来将css插入到页面的style标签npm install --save-dev css-loader 3.配置模块12345678module:&#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;, 2.js模块1.我们需要引入uglifyjs-webpack-plugin插件来压缩1const uglify = require(&apos;uglifyjs-webpack-plugin&apos;); 2.在配置文件的plugins中使用123plugins:[ new uglify()], 3.扩展配置12345678910111213141516new uglify(&#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;), 3. html模块1.我们需要引入html-webpack-plugin插件来压缩1const htmlPlugin= require(&apos;html-webpack-plugin&apos;); 2.在配置文件的plugins中使用12345678new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:&apos;./src/index.html&apos; inject: &apos;body&apos;, // 插入js位置 &#125;) minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。 hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template：是要打包的html模版路径和文件名称。 inject // 插入js位置 总结 不知道为什么使用title时，在html用&lt;%= htmlWebpackPlugin.options.title %&gt;无效4.图片模块1.在没有安装图片解析模块时，打包会报错因此需要安装file-loader和url-loader 1npm install --save-dev file-loader url-loader file-loader 解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。url-loader如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。 2.配置文件1234567891011121314module:&#123; rules: [ &#123; test:/\.(png|jpg|gif)/ , use:[&#123; loader:&apos;url-loader&apos;, options:&#123; limit:1024, outputPath:&apos;images/&apos;, &#125; &#125;] &#125; ]&#125;, test 是正则匹配文件名后缀 limit是图片大小，按B来算，大于设置的正常打包，小于的转成base64文件格式 outputPath:打包以后的文件存放的位置 url-loader中内置了file-loader，因此不需要使用 CSS分离与图片路径处理 CSS分离:extract-text-webpack-plugin1234567891011121314// 安装npm install --save-dev extract-text-webpack-plugin//引入const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);//设置pluginsnew extractTextPlugin(&quot;/css/index.css&quot;)//最后修改module代码 &#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;) &#125;, 图片路径问题 因为利用extract-text-webpack-plugin插件很轻松的就把CSS文件分离了出来，但是CSS路径并不正确，因此使用publicPath。 1234567891011// 先声明var website =&#123; publicPath:&quot;http://192.168.2.175:5050/&quot;&#125;// 使用，在ouput中output:&#123; path:path.resolve(__dirname,&apos;dist&apos;), //输出的文件名称 filename:&apos;js/[name].js&apos;, publicPath:website.publicPath &#125;, 打包生成结构12345678&lt;link href=http://192.168.2.175:5050//css/index.css?51a575862987b97bfc1c rel=stylesheet&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=title&gt;&lt;/div&gt; &lt;div class=img&gt;&lt;/div&gt; &lt;img class=tu src=http://192.168.2.175:5050/images/65a390bc1f6959cd92a090e77c7da2a1.jpg alt=&quot;&quot;&gt; &lt;a href=./demo/index.html&gt;demo页面&lt;/a&gt; &lt;div id=json&gt;&lt;/div&gt;&lt;script type=text/javascript src=http://192.168.2.175:5050/assets/js/vue.js?51a575862987b97bfc1c&gt;&lt;/script&gt;&lt;script type=text/javascript src=http://192.168.2.175:5050/assets/js/jquery.js?51a575862987b97bfc1c&gt;&lt;/script&gt;&lt;script type=text/javascript src=http://192.168.2.175:5050/js/entry2.js?51a575862987b97bfc1c&gt;&lt;/script&gt;&lt;script type=text/javascript src=http://192.168.2.175:5050/js/entry.js?51a575862987b97bfc1c&gt;&lt;/script&gt;&lt;/body&gt; html-withimg-loader html-withimg-loader解决的问题就是在hmtl文件中引入标签的问题。 安装：1npm install html-withimg-loader --save 配置：1234&#123; test: /\.(htm|html)$/i, use:[ &apos;html-withimg-loader&apos;] &#125; 总结：现在项目文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const webpack = require(&apos;webpack&apos;);const path=require(&apos;path&apos;);const uglify = require(&apos;uglifyjs-webpack-plugin&apos;); // js压缩文件const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 打包html文件const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);//css分离var website =&#123; publicPath:&quot;http://192.168.2.175:5050/&quot; // 判断线下&#125;var config = &#123; devtool: &apos;eval-source-map&apos;, // 用于开发调试，上线取消掉 // 入口文件 entry:&#123; entry: &apos;./src/js/entry.js&apos;, &#125;, // 出口文件 output:&#123; publicPath: website.publicPath, //或者&apos;./（本地可看），website.publicPath在服务器中可以&apos; //输出的路径，用了Node语法 path:path.resolve(__dirname,&apos;dist&apos;), // 输出文件名称 filename: &apos;js/[name].js&apos;, &#125;, // 模块，如解读CSS,图片如何转换，压缩 module:&#123; rules: [ &#123; test: /\.css$/, // loader: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [ &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &#123; loader: &apos;postcss-loader&apos;, options: &#123; ident: &apos;postcss&apos;, plugins: [ require(&apos;autoprefixer&apos;)(&#123;broswer: &apos;last 5 versions&apos;&#125;), //处理CSS前缀问题，自动添加前缀 ] &#125; &#125; ] &#125;) &#125;, &#123; test: /\.(png|jpg|gif)/, use:[&#123; loader:&apos;url-loader&apos;, options:&#123; limit:5000, outputPath:&apos;images/&apos; //打包到image目录下,注意只有大于设置的limit值才有效 &#125; &#125;] &#125;, &#123; test: /\.(htm|html)$/i, use:[ &apos;html-withimg-loader&apos;] //使用img标签不被打包 &#125;, //配置babel包 &#123; test:/\.(jsx|js)$/, use:&#123; loader:&apos;babel-loader&apos;, &#125;, exclude:/node_modules/ &#125; ] &#125;, // 插件 plugins:[ new uglify(&#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;), new htmlWebpackPlugin(&#123; minify:&#123; removeAttributeQuotes:true //是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号 &#125;, hash:true, //是否为所有注入的静态资源添加webpack每次编译产生的唯一hash值,有效避免缓存JS template:&apos;./src/index.html&apos;, inject: &apos;body&apos;, // 插入js位置 &#125;), new extractTextPlugin(&quot;/css/index.css&quot;), ], // 配置webpack服务 devServer:&#123; //设置基本目录结构 contentBase: path.resolve(__dirname,&apos;dist&apos;), // 设置服务器的ip地址 host:&apos;192.168.2.175&apos;, //&apos;localhost&apos;,或者电脑ip // 服务器压缩是否开启 compress:true, // 配置端口 port:5050, &#125;&#125;; scss文件打包分离安装node-sass：因为sass-loader依赖于node-sass，所以需要先安装node-sass1npm install --save-dev node-sass 安装sass-loader:1npm install --save-dev sass-loader 配置文件12345678910&#123; test: /\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // creates style nodes from JS strings &#125;, &#123; loader: &quot;css-loader&quot; // translates CSS into CommonJS &#125;, &#123; loader: &quot;sass-loader&quot; // compiles Sass to CSS &#125;]&#125; 编写sass打包12345678910.tu&#123; width:100px; height:100px; object-fit: contain; transition: all 1s ease; box-shadow: 0 0 0 #000; &amp;:hover&#123; transform: rotateY(360deg); &#125;&#125; 最终结构1234567891011.tu &#123; width: 100px; height: 100px; object-fit: contain; transition: all 1s ease; box-shadow: 0 0 0 #000;&#125;.tu:hover &#123; transform: rotateY(360deg);&#125; 自动添加后缀安装1npm install --save-dev postcss-loader autoprefixer postcss.config.js postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。 postcss.config.js12345module.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; 编写配置文件12345678910&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, use: [ &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ] &#125;)&#125; 生成1234567891011121314.tu &#123; width: 100px; height: 100px; -o-object-fit: contain; object-fit: contain; transition: all 1s ease; box-shadow: 0 0 0 #000;&#125;.tu:hover &#123; -webkit-transform: rotateY(360deg); transform: rotateY(360deg);&#125; 清除不需要的css安装PurifyCSS-webpack1npm i -D purifycss-webpack purify-css 目的删除没有用到的类 因为要查找全局1const glob = require(&apos;glob&apos;); 引入purifycss-webpack1const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;); 配置plugins1234567plugins:[ new PurifyCSSPlugin(&#123; // Give paths to parse for rules. These should be absolute! paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)), &#125;) ] Babel Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过便宜帮你达到以下目的：使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。使用基于JavaScript进行了扩展的语言，比如React的JSX。 安装依赖包1cnpm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 配置文件123456789101112&#123; test:/\.(jsx|js)$/, use:&#123; loader:&apos;babel-loader&apos;, options:&#123; presets:[ &quot;es2015&quot;,&quot;react&quot; ] &#125; &#125;, exclude:/node_modules/&#125; .babelrc配置新建.babelrc文件123&#123; &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]&#125; 这里安装了1npm install --save-dev babel-preset-env 在配置中设置1234567&#123; test:/\.(jsx|js)$/, use:&#123; loader:&apos;babel-loader&apos;, &#125;, exclude:/node_modules/&#125; 最后打包即可兼容最新写法 devtool的四种选项以及开发生产环境切换 source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度； cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。 eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。 cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。 开发生产环境切换通过在package.json配置12345&quot;scripts&quot;: &#123; &quot;server&quot;: &quot;webpack-dev-server --open&quot;, &quot;dev&quot;:&quot;set type=dev&amp;webapck&quot;, &quot;build&quot;: &quot;set type=build&amp;webpack&quot; &#125;, 修改配置文件如123456789if(process.env.type== &quot;build&quot;)&#123; var website=&#123; publicPath:&quot;http://xxx/&quot; &#125;&#125;else&#123; var website=&#123; publicPath:&quot;http://xxx.com/&quot; &#125;&#125; 最后通过不同命令打包不同文件 打包第三方库的方式1.直接在引入1import $ from &apos;jquery&apos;; 2.在配置文件的插件中使用1234567const webpack = require(&apos;webpack&apos;);plugins:[ new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot; &#125;)], 3.优化打包 在entey入口文件中引入 12345entry:&#123; entry:&apos;./src/entry.js&apos;, jquery:&apos;jquery&apos; vue:&apos;vue&apos; &#125;, 引入插件 optimize 12345678new webpack.optimize.CommonsChunkPlugin(&#123; //name对应入口文件中的名字,可以写入多个 name:[&apos;jquery&apos;], //把文件打包到哪里，是一个路径 filename:&quot;assets/js/[name].js&quot;, //最小打包的文件模块数 minChunks:2&#125;), 静态资源的打包安装copy-webpack-plugin1npm install --save-dev copy-webpack-plugin 引入配置1234567const copyWebpackPlugin= require(&quot;copy-webpack-plugin&quot;);//pligins中的配置new copyWebpackPlugin([&#123; from:__dirname+&apos;/src/public&apos;, //打包到的地址 to:&apos;./public&apos; //要打包的文件夹路径 &#125;]) 最后用到的插件热更新1new webpack.HotModuleReplacementPlugin() 查看代码打包结构12const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin; //代码结构new BundleAnalyzerPlugin() 每次打包删除dist文件夹123const CleanPlugin = require(&apos;clean-webpack-plugin&apos;); // 文件夹清除工具new CleanPlugin([&apos;dist&apos;]) 完成以后结构webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257const webpack = require(&apos;webpack&apos;);const path=require(&apos;path&apos;);const uglify = require(&apos;uglifyjs-webpack-plugin&apos;); // js压缩文件const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 打包html文件const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);//css分离const glob = require(&apos;glob&apos;); //同步检查html模板，所以我们需要引入node的glob对象使用const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;); //减少CSS冗余 ,注意必须先使用extract-text-webpack-pluginconst copyWebpackPlugin= require(&quot;copy-webpack-plugin&quot;);//没有引用的图片资源或者其他静态资源我们作静态资源转移的插件const CleanPlugin = require(&apos;clean-webpack-plugin&apos;); // 文件夹清除工具const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin; //代码结构const &#123; WebPlugin, AutoWebPlugin &#125; = require(&apos;web-webpack-plugin&apos;);// webpack使用html作为输入，并处理多页。if( process.env.type == &apos;build&apos;)&#123; var website =&#123; publicPath:&quot;https://www.xxx.xx.com&quot; // 线上 &#125;&#125;else&#123; var website =&#123; publicPath:&quot;http://192.168.2.175:5050/&quot; // 判断线下 &#125;&#125;var config = &#123; devtool: &apos;eval-source-map&apos;, // 用于开发调试，上线取消掉 // 入口文件 entry:&#123; entry: &apos;./src/js/entry.js&apos;, entry2: &apos;./src/js/entry2.js&apos;, jquery:&apos;jquery&apos;, // 优化js文件，将公共文件导出 vue: &apos;vue&apos; &#125;, // 出口文件 output:&#123; publicPath: website.publicPath, //或者&apos;./（本地可看），website.publicPath在服务器中可以&apos; //输出的路径，用了Node语法 path:path.resolve(__dirname,&apos;dist&apos;), // 输出文件名称 filename: &apos;js/[name].js&apos;, &#125;, // 模块，如解读CSS,图片如何转换，压缩 module:&#123; rules: [ &#123; test: /\.css$/, // loader: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [ &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &#123; loader: &apos;postcss-loader&apos;, options: &#123; ident: &apos;postcss&apos;, plugins: [ require(&apos;autoprefixer&apos;)(&#123;broswer: &apos;last 5 versions&apos;&#125;), //处理CSS前缀问题，自动添加前缀 ] &#125; &#125; ] &#125;) &#125;, &#123; test: /\.(png|jpg|gif)/, use:[&#123; loader:&apos;url-loader&apos;, options:&#123; limit:5000, outputPath:&apos;images/&apos; //打包到image目录下,注意只有大于设置的limit值才有效 &#125; &#125;] &#125;, &#123; test: /\.(htm|html)$/i, use:[ &apos;html-withimg-loader&apos;] //使用img标签不被打包 &#125;, &#123; test: /\.scss$/, use: extractTextPlugin.extract(&#123; use: [&#123; loader: &quot;css-loader&quot; &#125;, &#123; loader: &quot;sass-loader&quot; &#125;, &#123; loader: &apos;postcss-loader&apos;, options: &#123; ident: &apos;postcss&apos;, plugins: [ require(&apos;autoprefixer&apos;)(&#123;broswer: &apos;last 5 versions&apos;&#125;), //处理CSS前缀问题，自动添加前缀 ] &#125; &#125; ], // 分离scss文件 fallback: &apos;style-loader&apos;, &#125;) &#125;, // &#123; // test: /\.(scss|sass|css)$/, // pack sass and css files // loader: extractTextPlugin.extract(&#123;fallback: &quot;style-loader&quot;, use: &quot;css-loader!postcss-loader!sass-loader&quot;&#125;)// 简写css和sass // &#125;, //配置babel包 &#123; test:/\.(jsx|js)$/, use:&#123; loader:&apos;babel-loader&apos;, &#125;, exclude:/node_modules/ &#125; ] &#125;, // 插件 plugins:[ new uglify(&#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;), new htmlWebpackPlugin(&#123; minify:&#123; removeAttributeQuotes:true //是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号 &#125;, hash:true, //是否为所有注入的静态资源添加webpack每次编译产生的唯一hash值,有效避免缓存JS template:&apos;./src/index.html&apos;, inject: &apos;body&apos;, // 插入js位置 &#125;), new extractTextPlugin(&quot;/css/index.css&quot;), new PurifyCSSPlugin(&#123; // Give paths to parse for rules. These should be absolute! paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)), //src下的所有html &#125;), new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot; &#125;), new webpack.BannerPlugin(&apos;版权声明，或者修改声明&apos;), new webpack.optimize.CommonsChunkPlugin(&#123; //name对应入口文件中的名字，我们起的是jQuery name:[&apos;jquery&apos;,&apos;vue&apos;], // 防止webpackJson undefined // chunks:[], //把文件打包到哪里，是一个路径 filename:&quot;assets/js/[name].js&quot;, //最小打包的文件模块数，这里直接写2就好 minChunks:2 &#125;), new copyWebpackPlugin([&#123; from:__dirname+&apos;/src/public&apos;, //要打包的静态资源目录地址 to:&apos;./public&apos; //要打包到的文件夹目录 &#125;]), new webpack.HotModuleReplacementPlugin(), //热加载 // new CleanPlugin([&apos;dist&apos;]),// 清空dist文件夹 // new BundleAnalyzerPlugin(),// 查看代码打包结构 ], // 配置webpack服务 devServer:&#123; //设置基本目录结构 contentBase: path.resolve(__dirname,&apos;dist&apos;), // 设置服务器的ip地址 host:&apos;192.168.2.175&apos;, //&apos;localhost&apos;,或者电脑ip // 服务器压缩是否开启 compress:true, // 配置端口 port:5050, // 实时刷新 inline: true, &#125;, watchOptions:&#123; //检测修改的时间，以毫秒为单位 poll:1000, //防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作 aggregateTimeout:500, //不监听的目录 ignored:/node_modules/, &#125;&#125;;module.exports = config;var viesObj = getView(&apos;src/view/**/*.html&apos;, &apos;src/view/&apos;)var pages = Object.keys(viesObj);pages.forEach(function(pathname) &#123; var htmlName = viesObj[pathname] var conf = &#123; filename: &apos;./view/&apos; + htmlName + &apos;.html&apos;, //生成的html存放路径，相对于path template: &apos;./src/view/&apos; + htmlName + &apos;.html&apos;, //html模板路径 inject: &apos;body&apos;, //js插入的位置，true/&apos;head&apos;/&apos;body&apos;/false hash: true, //为静态资源生成hash值 // favicon: &apos;./src/img/favicon.ico&apos;, //favicon路径，通过webpack引入同时可以生成hash值 chunks: [&apos;common&apos;,htmlName],//需要引入的chunk，不配置就会引入所有页面的资源 minify: &#123; //压缩HTML文件 removeComments: true, //移除HTML中的注释 collapseWhitespace: false //删除空白符与换行符 &#125; &#125;; config.plugins.push(new htmlWebpackPlugin(conf));&#125;);// 获取全局的htmlfunction getView(globPath, pathDir) &#123; var files = glob.sync(globPath); var entries = &#123;&#125;, entry, dirname, basename, pathname, extname; for (var i = 0; i &lt; files.length; i++) &#123; entry = files[i]; dirname = path.dirname(entry); extname = path.extname(entry); basename = path.basename(entry, extname); pathname = path.join(dirname, basename); pathname = pathDir ? pathname.replace(new RegExp(&apos;^&apos; + pathDir), &apos;&apos;) : pathname; entries[pathname] = basename; &#125; return entries;&#125;// 获取全局的htmlfunction getEntry(globPath, pathDir) &#123; var files = glob.sync(globPath); var entries = &#123;&#125;, entry, dirname, basename, pathname, extname; for (var i = 0; i &lt; files.length; i++) &#123; entry = files[i]; dirname = path.dirname(entry); extname = path.extname(entry); basename = path.basename(entry, extname); pathname = path.join(dirname, basename); entries[basename] = &apos;./&apos; + entry; &#125; return entries;&#125;// 获取公共模块function getCommonsChunk(globPath, pathDir) &#123; var files = glob.sync(globPath); var entries = [], entry, dirname, basename, extname; for (var i = 0; i &lt; files.length; i++) &#123; entry = files[i]; dirname = path.dirname(entry); extname = path.extname(entry); basename = path.basename(entry, extname); entries.push(basename); &#125; return entries;&#125; potcss.config.js12345module.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; .babelrc123&#123; &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;] &#125; 学习链接： http://jspang.com]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
        <category>构建工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6初学]]></title>
    <url>%2F2018%2F03%2F19%2FES6%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[##ES6学习 1.ES6 搭建学习使用babel来转换 1.安装npm install -g babel-cli 2.本地安装babel-preset-es2015 和 babel-cli npm install –save-dev babel-preset-es2015 babel-cli 3.建立.babelrc文件123456&#123; &quot;presets&quot;:[ &quot;es2015&quot; ], &quot;plugins&quot;:[]&#125; 4.使用 babel src/index.js -o dist/index.js来转换 5.简化命令 “build”: “babel src/index.js -o dist/index.js” 6.安装 npm install -g live-server 输入 live-server 可以启动热加载然后使用npm run build即可 3.ES6的声明方式1.var 全局变量2.let 局部变量 （只在区块内起作用）3.const 常量 4.ES6的解构赋值 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 12345678910let [a,b,c] = [0,1,3]; //两边必须一致，否则会出错let&#123;f,g&#125; = &#123;f:6,g:7&#125; // 变量名前后必须一致console.log(f+g)let [h,i,l,j,k,m] =&apos;897654&apos;; //字符串console.log(h)console.log(i)console.log(l)console.log(j)console.log(k)console.log(m) 先赋值以后 可以加（）来解构 5.ES6的扩展运算符和rest运算符对象扩展运算符（…）：可以解决赋值问题function test(…arg){ console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);}test(1,2,3); let arr1 = [1,2,3]let arr2 = […arr1];arr2.push(4)console.log(arr1)12345rest 运算符 &gt; 当我们不确定有几个参数时，可以...xxx### 6.ES6的字符串模版ES6字符串模版用``包裹，可以标签等 var b=’飞车’var a = &lt;h1&gt;这是一段代码&lt;/h1&gt;${b}&lt;br/&gt;非常不错//再比如let [num1,num2] = [6,7];let num = ${num1+num2};console.log(num)12345&gt; es6的查找功能includes 判断是否存在startsWith() 判断开头是否存在endsWith() 判断结尾是否存在repeat() 复制 例如 &apos;emio|&apos;.repeat(3) 输出为emio|emio|emio| 7 ES6的数字操作二进制声明：12let binary = 0B010101;console.log(binary);// 输出21 八进制声明：12var b = 0o666&apos;console.log(b); //输出438 数字验证方法Number方法判断12345678var a = 11/4;console.log(Number.isFinite(a)) //true&lt;!-- 判断是否为整数 --&gt;var a=123.1;console.log(Number.isInteger(a)); //false&lt;!-- 转成整数或者浮点数 --&gt;console.log(Number.parseInt(a))console.log(Number.parseFloat(a)) 整数的取值范围 2的53次幂-1最大安全整数Number.MAX_SAFE_INTEGER;最小安全整数Number.MIN_SAFE_INTEGER判断是否超过安全整数Number.isSafeInteger(); 8.数组新增方法 JSON数组格式转换 Array.from()方法123456789let json = &#123; &apos;0&apos;: &apos;0&apos;, &apos;1&apos;: &apos;1&apos;, &apos;2&apos;: &apos;2&apos;, length:3&#125; let arr=Array.from(json);console.log(arr) 2.Array.of() 方法12var arr = Array.of(3,6,9,6,8);console.log(arr) //返回数组 3.find() 方法 返回满足条件的值 value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。12var arr = [1,2,3,4,5,6,7,8];arr.find() 4.fill() 方法把数组进行填充 接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。12var arr = [1,2,3,4,5,6,7,8];arr.fill(&apos;a&apos;,5,9)//输出 [1, 2, 3, 4, 5, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;] 5.for…of..方法1.for…of循环：输出的是值2.for…of xxx.keys()循环：输出的是下标3.同时输出数组的内容和索引：for (let [index,val] of arr.entries()){ console.log(index+’:’+val);}6.entries()实例方法 entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。(不知道怎么用。。。。。) 学习地址 技术胖带你玩转ES6视频教程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串常用的方法]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[charAt() 该方法输入一个下标，返回当前下标的元素位置 123var a = &apos;vuex&apos;a.charAt(2) // ea.charAt(11) // &apos;&apos; charCodeAt() 该方法是获取所选下边元素的编码值 1234var a = &apos;vuex&apos;a.charCodeAt(2) // 101a.charCodeAt(11) // NaNa.charCodeAt() // 118,a的值 indexOf和lastIndexOf 和数组的方法一样，返回第一次出现或者和最后一次出现的位置 12345var a = &apos;vuex&apos;a.indexOf(&apos;b&apos;) // -1a.indexOf(&apos;u&apos;) // 1a.lastIndexOf(&apos;a&apos;) // -1a.lastIndexOf(&apos;e&apos;) // 2 slice方法 同时数组方法一样，参数为开始位置和结束位置，为负数时，当前字符长度加上该负数（不包括end） 1234var a = &apos;vuex&apos;a.slice(0,2) // 输出为‘vu’a.slice(-3,4) // 实际为（1，4），即为‘uex’a.slice(-3,-1) // 实际为（1，3），即为‘ue’ substring方法 同slice方法类似，当值为负数时从0开始（不包括end） 1234var a = &apos;vuex&apos;a.substring(0,2) // 输出为‘vu’a.substring(-3,4) // 实际为（0，4），即为‘vuex’a.substring(-3,-1) // 实际为（0,0），即为‘’ substr方法 该方法表示从开始位置开始，到指定个数截至注意end值不能为负 123var a = &apos;vuex&apos;a.substr(0,2) // 输出为‘vu’a.substr(-3,4) // 实际为（1，4），即为‘uex’ replace 该方法替换字符串的内容。有两个参数，前者为old数据，后者为new数据例如 12var str= &apos;this is my name&apos;;str.replace(&apos;name&apos;,&apos;age&apos;) // 输出&quot;this is my age&quot; split方法 和join方法相识，是将字符串转换成数组 12var a = &apos;vuex&apos;a.split(&apos;&apos;) // 输出为[&quot;v&quot;, &quot;u&quot;, &quot;e&quot;, &quot;x&quot;] trim方法 该方法是去掉字符串开头和结尾的空格 12var str = &apos; trimeee &apos;str.trim() // 输出trimeee toLowerCase() 和toUpperCase() 前者将字符转成小写，后者将字符转成大写 1234var str = &apos;abcdefg&apos;str.toUpperCase() //输出为 ABCDEFGvar str1 = str.toUpperCase();str1.toLowerCase() //输出为abcdefg]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组常用到的方法]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组方法 push 向数组最后面追加一个元素，例如： 123var arr = [];arr.push(1); console.log(arr) // 输出arr = [1] pop 删除数组的最后一个元素 ，例如： 123var arr = [&apos;a&apos;,&apos;b&apos;,&apos;v&apos;]arr.pop();console.log(arr) // 输出arr= [&apos;a&apos;,&apos;b&apos;] unshift 向数组最前面添加一个元素，例如： 123var arr = [&apos;a&apos;,&apos;b&apos;,&apos;v&apos;]arr.unshift(&apos;c&apos;);console.log(arr) // 输出arr= [&apos;c&apos;,&apos;a&apos;,&apos;b&apos;,&apos;v&apos;] shift 删除数组的第一个元素，例如： 123var arr = [&apos;a&apos;,&apos;b&apos;,&apos;v&apos;]arr.shift();console.log(arr) // 输出arr= [&apos;c&apos;,&apos;b&apos;,&apos;v&apos;] slice 截取数组长度，参数伟（start，end）注意 end不包含 123456var arr = [1,5,9,46,7]var b = arr.slice(2,3) console.log(b) //输出为9var c = arr.slice(-3,6)console.log(c) // 为负时，长度加上负值 2，6 最后值为[9, 46, 7] splice 有三个参数[start，index，container]表示开始位置，几个元素，最后添加那个元素 12const index = this.list.indexOf(row); //找到修改的数据在list中的位置this.list.splice(index, 1,this.updatedData); //通过splice 替换数据 触发视图更新 join() 数组转换成字符 reverse() 反转数组 sort() 数组排序，穿两个参数 （a,b） return a-b 升序 return b-a 降序 indexOf() 获取在数组中，第一次出现的位置 没有就返回-1 lastIndexOf() 与indexOf() 相反，获取最后一次出现的位置]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3例子]]></title>
    <url>%2F2018%2F03%2F10%2FCSS3%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[CSS3 例子 拷贝地址： https://nate-river.github.io/git/2016/09/21/css3-example.html 边框和背景半透明边框 多重边框 背景定位1 背景定位2 背景定位3 边框内圆角 水平条纹 垂直条纹 对角条纹 对角条纹60度 复杂条纹 蓝网格图 圆点图 棋盘图 棋盘图-svg 旋转动画 随机条纹 边框图片 连续的边框图片 古老的信封背景实现 古老的信封边框实现 行进的蚂蚁 页脚 形状椭圆 半椭圆 4分之一椭圆 平行四边形 利用伪元素的平行四边形 钻石图片 钻石图片效果 四角直切图片 四角圆切图片 使用边框的切角 平行四边形选项卡 圆饼动画 静止饼图 五彩流动 svg饼动画 视觉效果一侧阴影 双侧阴影 反向阴影 投影滤镜 图片滤镜 变色的老虎 透明背景文字 卷脚 卷脚2 字体处理文本均分 断行 隔行色 代码tab数量 个性下划线 更个性的下划线 文本阴影 空心文字 发光文字 3d文字 圆环文字 用户体验禁止的按钮 扩大点击区域 复选框 点击切换样式的按钮 方便的遮罩 模糊遮罩 滑动到底部顶部的提示 可拖动的图片遮罩 动画效果弹球 android风 android动画 帧动画 闪烁 打字效果 静态播放动画 转动动画 转动动画2 弹性布局intrinsic-sizing styling-sibling-count fluid-fixed vertical-centering-text vertical-centering vertical-centering-vh vertical-centering-abs sticky-footer-fixed sticky-footer]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex的应用]]></title>
    <url>%2F2018%2F03%2F09%2Fflex%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[flex的学习 例子: flex的布局1 第一步是让需要的元素 display：flex,注意的是，一旦flex，浮动就会失效用在容器上 flex-direction （布局方向，是从上到下还是从下到上，或者是从左到右，从右到左） flex-wrap （决定怎么排列的，一列放不下以后是按正常，还是元素不下来，继续一行显示，或者是长的在下，短的在上） justify-content （是垂直显示在页面，有点类line-height的属性） align-items （显示位置，是紧靠顶部，还底部展示，还是居中显示，或者是满屏展示，一般控制单行的元素） align-content （和align-items类似，可以控制多行）用在子元素上 order （这个属性可以调整div的位置，数越小，排在前） flow-grow （后面跟数值，数值越大，所占的百分比就越大） flex-shrink （没有实现，没有用到） flex-basis （数字位百分比，百分比越大，占得空间越大） flex （是flow-grow，flex-shrikn,flex-basis的简写,一般情况下都用flex来描述） align-self （这个元素可以控制位置的变化，跳出整体布局 ） flex-direction图解 html布局 12345&lt;div class="direction"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt;&lt;/div&gt; css布局 1234567891011.direction&#123; display: flex;&#125;.direction .item&#123; margin:1em; width: 200px; height:50px; line-height: 50px; text-align: center; background: #6d74da;&#125; column-从上到下排列 123.direction&#123; flex-direction: column;&#125; column-reverse-从下到上排列 123.direction&#123; flex-direction: column-reverse;&#125; row-从左到右排列 123.direction&#123; flex-direction: row;&#125; row-reverse-从右到左排列 123.direction&#123; flex-direction: row-reverse;&#125; flex-wrap图解nowrap 不换行 123.direction&#123; flex-wrap: nowrap;&#125; wrap 第一行在上 123.direction&#123; flex-wrap: wrap;&#125; wrap-reverse 第一行在下 123.direction&#123; flex-wrap: wrap-reverse;&#125; justify-content图解为了方便以下图片引用当前地址 align-items图解 align-content图解 order图解 1234# 例如.item&#123; order:-1&#125; flex-grow图解123456789# 当前代码所展示的图如下.grow span&#123; flex-grow: 1; background: #6d74da; margin:1em;&#125;.grow span:nth-child(2)&#123; flex-grow: 3;&#125; flex-basis 图解123456# 当前代码所展示的图如下.basis span&#123; flex-basis: 20%; # 宽度20% background: #6d74da; margin:1em;&#125; flex图解123456789# 当前代码所展示的图如下.first-Grid .Grid-cell&#123; flex:1; height: 50px; margin:10px; text-align: center; line-height: 50px; background: #6d74da;&#125; align-self图解123456789# 当前代码所展示的图如下.direction&#123; # 父元素 display: flex; align-items: flex-start; height: 150px;&#125;.direction .item:nth-child(2)&#123; align-self: flex-end; # align-self的值 auto | flex-start | flex-end | center | baseline | stretch;&#125;]]></content>
      <categories>
        <category>css</category>
        <category>flex</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>css</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo编写文章以及主题更改]]></title>
    <url>%2F2018%2F03%2F06%2Fhexo%E7%BC%96%E5%86%99%E6%96%87%E7%AB%A0%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%94%B9%2F</url>
    <content type="text"><![CDATA[1.hexo的基本操作 新建文章 - 生成的文件在根目录的source下 1hexo new post &apos;title&apos; 新建页面 - 生成的文件在根目录的source_posts下 1hexo new page &apos;title&apos; 打开生成的页面的md 12345678910title: 测试 # 文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2018-03-03 15:56:26 # 文章生成时间categories: # 文章分类目录，参数可省略 也可用数组 - 分类1 - 分类2tags: # 文章标签，参数可省略 也可用数组 - 标签1 - 标签2---这里开始使用markdown格式输入你的正文。 插入图片访问hexo关于图片上传 2.配置根目录下的_config.yml1234567# Sitetitle: 标题 # 网站名称，会在标签页上显示subtitle:副标题 # 副标题description: #网站描述，便于搜索引擎用关键词搜索 author: #作者language: zh-Hans #语言，中文 用的next主题timezone: #网站时区 3.next主题应用主题选择地址 根据主题的介绍安装 修改根目录下的_config.yml下的 theme: next 修改根目录下的_config.yml下的 language: zh-Hans 语言选择 选择风格themes\next下的_config.yml123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini hexo的个性化配置1.生成加密文章 找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。 添加 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 给需要添加密码的文件的头部插入password：xxxxx最终会在点击文章时显示请输入密码 2. 添加Rss 在根目录打开git输入 1npm install --save hexo-generator-feed 在根目录下的_config.yml 1plugins: hexo-generate-feed 在主题下的_config.yml 1rss: /atom.xml 最后执行预览 1hexo s -g 3. 打开画布背景 在主题下的_config.yml1canvas_nest: true # 原来是false，改为true 4.打开头像 打开主题下的_config.yml 1avatar: xxxx.gif #后面为图片地址 头像旋转 — \themes\next\source\css_common\components\sidebar\sidebar-author.styl添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 5. 代码区高亮 打开\themes\next\source\css_custom\custom.styl 添加下面代码 颜色自定义123456789101112.highlight .code pre&#123; background-color:#31383b;&#125;.highlight .line&#123; color:#ededed;&#125;.highlight&#123; background-color:#31383b;&#125;.highlight .gutter pre&#123; background-color:#364e59;&#125; 6. 修改文章底部的那个带#号的标签 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 7. 在网站底部加上访问量以及字数统计 打开\themes\next\layout_partials\footer.swig文件,在合适的地方加上这句话： 12345&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&amp;nbsp;&amp;nbsp;|&amp;nbsp;&amp;nbsp;您是第 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 位访客&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 在根目录下执行 1npm install hexo-wordcount --save 打开\themes\next\layout_partials\footer.swig文件,在尾部加上这句话： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 8. 设置favicon 照一张ico图标，放入/themes/next/source/images里，并且修改主题配置文件：123favicon: small: /images/favicon.ico medium: /images/favicon.ico 9. 顶部进度条 打开主题下的配置选择pace的方式，并把pace设为true10. 博客添加宠物 第一步输入 1npm install --save hexo-helper-live2d 第二步在跟目录下的配置文件尾部添加 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-wanko // 如果没有就 npm install --save live2d-widget-model-wanko display: position: right width: 50 height: 100 mobile: show: false //true是一直显示，false手机下不显示 11. 评论功能 使用來比力 注册來比力 选择安装，选择City会与一段代码 123456789101112131415161718&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;xxxxx&quot;&gt; // xxxx为你的your uid&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在主题配置中找到下列 ，并将liver_uid替换成你的uid 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 执行预览 如果不想评论，可以在头部加comments: false 1234title: hexo编写文章以及主题更改date: 2018-03-06 17:26:55categories: comments: false 12. 搜索功能 安装 1npm install hexo-generator-searchdb --save 修改根目录下的配置文件，添加下面代码到任意地方 12345search: path: search.xml field: post format: html limit: 10000 修改主题下的配置文件,将 local_search: 下的enable: true 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true //改为true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 参考文件 https://segmentfault.com/a/1190000009544924#articleHeader33]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo关于图片上传]]></title>
    <url>%2F2018%2F03%2F06%2Fhexo%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[hexo中使用markdown的图片问题 打开根目录下的_config.yml 查看post_asset_folder并设置为true 执行命令行 123456 npm install https://github.com/CodeFalling/hexo-asset-image --save ``` 4. 添加新文章 hexo new &apos;xxxx&apos;此时文档结构为：![](hexo关于图片上传/hexo3.png)5. 地址为 ![] (hexo关于图片上传/xxx.png) 现在格式 以前格式`这样便可以显示图片，而不是加载失败]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启高效学习的大门]]></title>
    <url>%2F2018%2F03%2F05%2F%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第一章：掌握时代学习模式，或被时代碾压身亡我在写程序时要查以下ES6箭头的作用于，于是开启了百度，查找ES6，在查找时我发现了《古天乐失手甩名表》的热点新闻，出于好奇心，我就点进去查看了。这种娱乐新闻阅读起来让人身心愉快，欲罢不能。看完了这个，我又阅读了《埃及发现女祭司墓》的热点新闻。两篇文章读后发现20分钟已经过去了，但这些信息跟我有什么关系。我关心的ES6箭头函数问题根本没有解决，我的能力也没得到丝毫提升。最多算是增加了一些谈资。但领导已经开始来催程序了，我就完全跑偏了。 随着互联网和移动时代的发展，身边的信息越来越多。如果说读书是在思想的游泳池里畅快地撒欢儿，那上网就像是在大海里游泳，永远看不到地平线。有时候你以为发现了一个岛屿，当你游过去后，却沮丧地发现那是一个浪头——让你觉的更加虚空。唯一安心的是，身边还有一群同样迷失的人，他们还相互点赞。 有三种人会被时代的车轮无情的碾压，他们也很努力，甚至比我们一些人更努力，但是就是因为他们不知道时代在变化，学习方式、工作方式也发生了变化。 第一种：无法掌握自己注意力的人对于一个程序员来说，能否驯服自己的注意力比是否专业更加重要，因为我们的职业决定我们几乎上班就在线，随时收到任何信息的干扰。其他职业或者说过去，知识是内在财富，而手头工作是老板给的，你只需要更具老板的要求输出知识；而程序员，知识可以从外面供给，注意力却必须内在拥有，你需要调用内在注意力抓取知识。如果你没有驯服注意力的能力，你的时间、思维会被完全打碎，这时候你的大脑就变成了豆腐脑。举个简单的小例子：比如说厨师他的知识是内在的，每天上班只要不断的重复输出已经学会的炒菜技巧，就会越来娴熟，老板也会很满意。但程序员的工作大多是在查看API和写程序调试，至少一半的时间都在网上冲浪，也就是说你知识是互联网从外面供给的，如果你管理不好你的注意力，你就会不断跑偏，一无所获。 第二种：无法过滤信息，找不到重点的人对于一个程序员，查找信息和辨别信息的能力非常重要，重要到每天上班都要使用，就像吃饭睡觉一样。在这个信息过剩的时代，每天能听的课、能看的书、能做的事、能用的东西实在事无穷无尽，根本学不完，到底该学什么？你身边你的人还一个比一个努力，似乎都是机会，又都无从下手，到底该投入哪一个?我所处的领域是Web大前端，每天都在有新的框架或者新的东西产生，如果你全部跟风学习，会把自己累死。那个最简单的构建工具来说，我最早接触的grunt，当时也花了不少精力去研究，刚研究出点明堂，这时候公司又开始使用Gulp，于是完全放弃了Grunt，投入了Gulp的怀抱。一个项目之后，大家又都开始玩起webpack来。这些变化都发生在这3年内。学的东西太多了，感觉我们精力完全透支了。如果你没有应对方法，那你必将精尽而亡。 第三种:无法交流想法，不能联机协作的人我们公司全面启用了企业微信，很多同事也许我叫不上来名字，但是每天我们都在企业微信中协调讨论，并一起完成工作。学习也是一样，当你接受到一个新知识的时候，你是没有过去成形的知识的，你该通过找谁能让自己开窍，或者在网上找那些资源能让自己入门？在一个每天海量信息涌入的不确定性时代，事实是什么不重要，也许一群人能合作解决问题才是关键。联机其实有两层含义： 人和电脑或者移动智能设备配合，用现代化工具来提升自己的学习效率，当然如果你是一个程序员，这点不需要太多的解释，因为联机工作学习是程序员必须掌握的技能之一。 人与人的联机，现在软件行业的发展已经不再是单打独斗，超级英雄的时代，越是大公司，越是分工明确，一个软件你只要做好其中一项工作，然后由项目经理协调组织，才能构成完美的软件。我相信在不久的将来利用大数据和人工智能一定能够实现下面的情景: 来到办公室(或者你根本你不用去办公室)，打开电脑，程序会根据你已有的工作量自动抓取全中国最适配和最佳报酬的任务推送到你面前。然后根据自己喜好选择这些任务，你根本不需要知道这项任务的老板是谁，你在为谁工作。 读到这里，你应该停下来想一想，是不是存在上边所说的三种问题，如果有薄弱的地方，那你应该好好阅读下面的文章，学会一种新的学习方式。 第二章：外包大脑，提升10倍效率，高手的暗箱大脑不该用来记忆，而是要用来观察、思考、创造和影响他人。这可能跟我们以前的认知不太相同，记得上学时老师都会说学习不好的学生：“你的脑袋怎么这么笨？讲过的知识都记不住。……”老妈也会唠叨我脑袋不好使，记不住东西。放佛从小我们接受的教育就是，大脑是用来记忆东西的，你的记忆力好坏直接影响学习成绩。我不否认，在学习阶段大脑的记忆能力直接影响你的成绩。但这个时代，或者说你已经走出了校门，就应该抛弃这种想法，把大脑记忆部分外包出去。 以下来自引用： 2009年，精神病学教授盖里.斯莫尔（Gary Small）发表了研究论文《谷歌如何作用于大脑》。他找到24名研究对象，其中12人经常使用搜索引擎，另外12人很少使用，分为两组。每一个人上网时给他们脑部作核磁共振，研究发现使用搜索引擎的时候，人们大脑中处理问题决策的区域活跃度会上升，经常使用搜索引擎的12人在实验中的脑部活动时很少使用搜索引擎人的两倍。 如果你试想一下，写程序时遇到一个问题，你去网上搜索答案，并找到了解决的方法，你往往记住的不是这些解决方法，而是如何解决的过程，也就是说你掌握了从哪里找到这些信息的方法（甚至我们会放到收藏架中）。在某种意义上说互联网已经成为人们将信息存储于大脑之外的外部记忆或者说交互记忆的基本形式。这个时代发生的改变你可以想象成为，以前我们下了很多电影（什么电影我们先不管），以前我们为了下载更多的电影，需要购买更大或者更多的硬盘，而现在不需要了，随着网络带宽的增加和云盘的发展，我们只需要把这些东西放到云盘上就好。这就是我们存储或者说记忆的时代变化，不管你信不信，他已经成为主流。 可能有些人会站出来大骂技术胖，按你这样说，以后人岂不是都要变成傻子了吗？事实并非如此。人类历史上大脑已经发生过三次外包，人们并没有变傻一点，而是一次比一次聪明。 第一次外包：第一次是语言的出现，正式通过神奇的语言，单机式的大脑变成了联机式的：通过讲故事，人类可以一起协作，去打败比自己强大的动物，而通过聊天，人类可以走出150人的小圈子，与陌生人协作。讲故事让人类进化，在《人类简史》一书中已经说明了，这次大脑外包带来的重要意义，它让智人崛起，成为地球目前的王者。（《人类简史》这本书非常值得一读，并且有趣，如果你敲代码累了，可以读读本书，消遣一下） 第二次外包：是书和印刷术的出现。书的出现极大提高了人的记忆力、思考力和影响力。有了文字，我们才不用什么都记，这让人们可以实现选择性记忆了；复杂的运算和逻辑推理，只有写下来才有可能实现，这让我们的思维能力更加精确；而有了书，让我们的思想可以传播的更加久远。比如我们的四大名著，还有我们读的《论语》，书的出现才会让智慧积累。也是以为这次大脑的外包，走出了语言短暂又不精确的限制，读写能力成为教育体系的新宠。 第三次外包：是互联网的出现。这次我们把记忆能力外包给了搜索引擎，把协作外包给了网络，把体力和职能外包给了机器。这一切的实现基础都是网络——但网络提高的不是记忆能力，而是到达速度。其实这些信息，大部分在书里也有，所不同的是你自己找书的速度和使用搜索引擎的速度，提高了千倍以上的速度。包括现在马斯特研究的人机接口（就是把人和网络/机器相连），实现更快速的查找能力，这时候人们就再也不用记忆了，而是剩下能量去观察和思考。说了这么多，其实只有一个目的，就是说服您：大脑不该用来记忆，而是要用来观察、思考、创造和影响他人。这是你改变学习方法或者说改变程序人生的第一步，如果你有幸认识某个方面的专家，你会发现他们在使用这个方法，可以说是现在高手必备的知识，你一定要看清和理解社会变化带来的学习方法不同，以及掌握这些最新的学习技能。 程序员，如何做到大脑外包那？ 我举个最简单的例子，比如我是一个前端，那我的基础知识就是HTML+CSS+JavaScript，这些我们必须完全掌握，并且达到熟练应用，但是比如Vue、React这些框架就没必要记住所有知识点，而是在使用时去查API，然后快速解决问题。有很多小伙伴会说我看API很费力气，或者完全不知道如何操作，这就是你的基础没有打好，就相当于你还不会使用网络和计算机。这跟我们在学校收到的教育完全两样，可能这种在学校里叫做作弊，抄袭。但如果你步入社会后，依然用学校的学习方式，时代的车轮一定会把你碾压身亡，特别是在程序这个领域，你记忆的速度根本没有知识产生的速度快。 如果你能把大脑外包这个技能熟练使用，你发现学什么都不难么难，学会20%得基础，解决80%得问题，剩下的你就可以使用快速查询大脑外包的方法，解决工作中的问题。当你用这个技能工作1年到2年后，你自然成为这个领域的高手。以下是引用： 未来是一个个体崛起的时代，却不是每个个体都崛起的时代，顺应时代的人快速高效崛起，其他人舒服地被机器圈养，这是一个留下少数巨人，一堆侏儒的时代。 这个时代信息变多，思考变浅；机会变多，竞争跨界；随时干扰，永远在线。德国作家赫尔曼.黑塞在其名著《在轮下》里写到: 面对呼啸而至的时代车轮，我们必须加速奔跑。有时会力不从心，有时候会浮躁焦虑，但必须适应。它可以轻易地将每一个落伍的个体元元抛下，碾作尘土，且不偿命。 如果上述文字还是没办法舒服你，因为你是技术胖最贵的付费阅读用户，我觉的你还是应该先试一试，看看是否学习效率会提升，刚开始可能是提升10%，然后20%，一点点累计增加。我相信你一定可以完成10倍学习效率的提升，这是你跑赢身边其他人的关键一步。 第三章：二八法则和高价值区，人生的捷径在这个时代里，没有一个国家的财富是 平均分配的，经济学家研究国家的财富都呈现出一种分布方式，少部分人占据了大部分财富，而大部分人拥有少量财富，也叫做幂律分布或者长尾分布。 幂律分布的主要特征，就是高度的不平均。很多书里把这种分布叫做“二八法则”、“马太效应”或者时“长尾理论”。社会中拥有大量的降幂分布，比如说20%的客户带来80%的生意，20%的人占有80%的财富，20%的词汇表达80%的信息…….可能有的小伙伴会说，这些都是特例，并不能归为规律，那你就错了，比如说：月球上陨石坑直径分布，国家人口的分布，网页点击的次数，论文被引用次数，奥斯卡奖项的分布，全部都符合幂律定律。再直接点告诉你，不公平就是大自然的一种常态。如果你刚走出校园，你可能无法接受这种不公平，这和学校还有从小家庭的教育根本是背道而驰。你在学校里可以天真，可以认为世界是公平的，只要努力就会有希望，就能走向人生巅峰。但是你步入社会后，我劝你还是丢掉你的小天真，接受这个不公平的真相。只有接受才能改变，如果你再聪明一点你会发现既然有了不公平，肯定就有不公平的升级方法——在一个流动、开放的社会里，阶层分化是稳定且可预见的（天机已泄露）。 抢占头部比努力更重要为了讲清楚这个道理，我们不提什么世界最高峰是什么？第二高峰是什么这样已经被问烂的问题。如果你已经工作了，我问你们公司前端最厉害的人是谁?我相信80%的人可以脱口而出，但是我问你第二厉害的人是谁，这时候大家就都答不上来，或者答案不一。再问你，你们公司谁拍照最好，你可能也能马上回答出来，但第二那?这就是公司系统里的头部效应。在一个系统里，头部品牌吸引的注意力大概占40%，第二名是20%，第三名是7%-10%,其他所有人共分其余的30%。头部会带来很多的关注和个人品牌影响力，这些都会提高你能力的溢价，带给你更高的收益。一旦你成为某个系统里的头部，系统就开始产生正反馈——微小的优势会带来更多名声，名声给你更多机会，更高收益。这又让你可以投入更多资源，继续扩大优势，最后的结果就是头部的人嗯获得最高的增长率。好的程序员提升需要三个要素：好的方法论，可以练习，大量的实战机会。在头部的人会同时拥有这三个机会。一个公司里的前端架构师，应该有最多的学习机会，获得最多的实战机会，拥有最多的资源配置。拥有了这些，公司里的其他前端程序就很难跑赢他了。收益不仅和能力有关，更与站位相关。优秀是一种系统的显现。很多人看到这里肯定会在心里问。我刚接触程序一两年，现在根本没办法进入一个系统的头部，那我是不是就没有机会了？答案是否定的，先进入自己能进入的头部，去最好的城市，去最热门的领域积累资源、增长见识，与伟大同行。 头部效应解决就业、择城为了更好的理解这章的内容，举几个程序员最常产生的疑虑，并用二八法则和头部效应的思想解答一下。 大公司，还是创业公司？QQ群里的小伙伴May问我，我进入前端领域1年了，现在有两个机会：一个是去携程作实习生，一个是去创业公司作主程。选择哪个?当时我并没有回答她，因为我觉的这样的建议不能随便给，因为变数太多，人的性格大不相同，我们彼此更不了解（在这里也奉劝大家，不要随便给人建议，解忧杂货铺只存在于小说或者电影里）。在这里我也不给May任何建议，但是我可以借助这章学的内容帮你分析一下。如果这节创业公司不算太离谱的话，可以根据头部法则选择去作主程。携程虽然是一线互联网公司，但是你是作实习生，你得到的资源和机会很少。这就相当你去了一个航空母舰上工作，结果实际工作是拧螺丝一样。去创业公司，虽然不是什么大船，但是只要在快速学习上突围，主程会等到更多的资源。俗话说的好，宁做鸡头不作凤尾，个人觉的这句话是正确的，因为鸡头可以得到更多资源，再加上自己的努力，你会比凤尾提升的快的多。如果你真的选择了创业公司，请不要选择安逸（在小公司的大牛，可能在大公司并不算什么）。可能你在公司里是大牛，但是你的竞争对手并不在公司内，你要向外看，全行业的人都是你的竞争对手。到了公司要根据自己的情况，选择一个专一的放心，专精下去，这样你2-3年之后，在行业里才能出类拔萃，技压群雄。不要被企业大小所迷惑，抓住高价值的头部区域才是机会。 是否离开北上广？作IT的人都知道北上广深是乐土，工资高，机会多。但是随着年龄的增长你会成家，会面临要照顾父母，会考虑孩子的就业。这时候会有很多人，问我到底是该回老家，还是继续留在大城市打拼。这个问题也太大了，遇到这样的问题我都不会头疼。但是问的人多了，发现也可以利用头部理论来解决问题。如果还处在高增长阶段的人，最好选择在大城市再待几年，看能否跻身头部；如果增长放缓，回家乡也是一种聪明的战略性转移，关键是如何让自己在二三线城市过好。（其实大城市就是一个国家的头部，如果不考虑个人因素，在大城市一定可以跑赢小城市的人）如果你已经在程序员领域走向了自由职业者，完全可以通过网络实现“身在老家，心在中关村”。但是大部分程序员都会落入一个误区：先想优势，再找价值——我这么牛的编程能力，如何在老家更有用？我清华大学毕业，在老家能干什么？这种想法的结果一般都不会太好。你需要先找价值，再想优势。现在很多三四线城市企业都面对互联网转型，但是向匹配的人才却非常少，这就是高价值区。要在为传统企业转型上多烧脑，多下功夫，再配合你的优势。你才能快速升级，实现自我价值。 第四章：两条学习秘诀，让你保持领先如果你前三章学好了，并且进入了你专研技术的头部（可能需要1-2年的时间你才能跨域这一步），这时候你享受着头部所带来的所有红利，你的优秀也会为你引来很多追随和模仿者。那如何保持优势，防止后来者居上那？其实很简单，那就是专注。一个聪明人，精力是正常人的两倍，智商是正常人的两倍，这算是天才了吧。但这个人把精力分3个目标，他就马上会在这三个领域分别被三个综合能力不如他的选手击败。这也是我们学习或者说是聪明人的终身诅咒——贪婪而不专注。 那对于聪明人（80%的人认为自己比其他人更聪明），为什么专注这么难？因为越是聪明人，眼界越开阔，面临的机会越多，可能越多，领域越多，一做就有小成，轻松歼灭低级对手，更加觉得自己厉害，所以越发不专注。上天给你无限的机会，却只给你有限的时间、精力和才华，所以越是优秀，越要专注。如果无法保持专注，再聪明也是暂时的，并不能成为一个领域的大神。太多的聪明人死于不专注，你可以想想现在的程序大神，都是专精于一个方向，很少有全能型的大神在程序界一直保持不便。有的只专注于CSS，有的只专注于Javascript，有的只专注于Canvas，有的只专注于某一框架，很少有全能型的顶级大神出现。 在程序这一行中，保持专注非常重要，但也很难，因为发展的太快，比如我所处的前端领域，几乎每天都有新的知识和框架出现。有时候我也会跟风学习，但你记住，在CSS和JavaScript这样底层的知识中，你一定要保持专注，其他新产生的知识只是它们的升级。比如阿里的前端专家大漠老师（大漠和大漠穷秋是两个人），十几年专注于CSS，终究练成大神。所以说三流高手靠努力，二流高手靠技艺，一流高手靠专注。专注是防守的方式，能让已经处于行业头部的人，保持领先。但我相信大多付费看这篇文章的人还没有进入行业头部，所以你们更需要的是进攻的招式。 迭代：聪明人的笨功夫很多人在学程序的时候都希望速成，于是市面上出现了《21天精通JAVA》，《21天精通Javascript》等一些列速成的书。我不知道谁靠着这些书成为了优秀的程序员，也许真的会有吧，但我个人的经验是用最笨的办法不断迭代。 程序这东西其实是需要耐下心一点点研究的，也许做出一个Demo很简单，上手一个项目也很容易。但是你要了解他的所有特性却没那么容易，我们还是拿CSS为例，很多人简单的学个一周就可以写小Deom，专研个1个月，就可以应对大部分项目。但是如果想完全精通，适配各个浏览器，移动端和制作动画，你至少需要一年你的功夫，所以我建议前端的小伙伴不要对CSS那么不屑一顾，如果你刚入行，最好想切图两年，把基础打好，不要急于求成。很多业界有名的CSS大神都是10年以上的迭代和专注。 这里拿自己举例子：在录制Vue视频之前，我已经使用Vue一年多了，但这种使用，只是在公司作项目，当时觉得项目中的所有效果都可以做出来，已经非常精通了，于是决定开始录课。在录课的时候发现自己还有很多欠缺，然后不断迭代，专注于Vue的每个知识点，就这样反复学习过后，我才开始录制第一节课。就是这样，在录制时还在不断打磨每个知识点和Demo，这又是一次迭代和专注的过程。每一次迭代我都有新的认识，有新的收获，现在我还是在工作种使用Vue，还在不断迭代种。经过两年多的迭代以后，我终于在我们公司占领了Vue头部，小伙伴们在使用Vue编程遇到问题也会向我咨询。我也开始在互联网上吸引一些人跟我一起学习Vue和前端的知识。 我还不够成功，并不能说服你们，那举一个成功人士——李昌镐。以下来自网络摘抄： 下围棋的人都知道韩国骑手李昌镐，他16岁就夺得世界冠军，被认为是当代仅次于吴清源的棋手，巅峰时期横扫中日韩三国棋手，号称“石佛”，是围棋届一等一高手。 李昌镐下棋的最大特点，就是——很少有妙手。妙手就是指围棋中精妙的下法，有时候，一着妙手或解开困境，或扭转败局，甚至可以一子制胜。《天龙八部》里虚竹随手破解珍珑棋局，就是一个妙手，帮他扭转人生，成为武林中内力最深厚之人。厉害的李昌镐为什么没有妙手?一名记者曾问他这个问题，他憋了很久说：“我从不追求妙手。”“为什么？妙手可是最高效率的棋啊！”“……每手棋，我只求51%的效率。”记者愣住了，只求51%的效率？众所周知，棋子效率越高越占优势，高效行棋，自古以来就是棋手追求的目标。李昌镐又说：“我从来不想一举击溃对手。”记者再追问，他沉默了。为什么世界第一的棋手，每子只追求51%的效率? 妙手不能迭代，无法刻意练习妙手其实在艺术人眼里就是灵感。灵感说来就来，说走就走，灵感没法刻意练习，没法迭代升级，这是妙手的最弊端。一个程序员，是靠手艺吃饭的，练的是硬功夫，就和修鞋匠或者厨师差不多，我们只有不断迭代基本功，才能进步。 许多作家第一本书写的很好，但是之后就再无佳作；有些歌手，第一张专辑是天籁之音，后来却不尽人意。我还听说很多作家歌手靠吸食毒品来寻找灵感。他们总觉的自己缺乏灵感，其实他们缺少的是专注于可迭代的真正技术。 通过李昌镐的例子，我想你应该明白这章我讲的内容了，在占领头部后你要作的是专注和不断迭代。别以为这很容易，这是反人性的一种操作，是需要强大的自制力才能做到的。新手看胜负，高手看概率。高手知道大胜都是细小优势的持续迭代形成的。 第五章：功利学习法，颠覆学习认知，跑赢90%我记得几年前流行这样一句话：不以结婚为目的的谈恋爱，都是耍流氓。那学习也是一样，没有目标的学习都是耍流氓。在这个知识包扎的时代，知识早就多到学不完了，如果漫无目的的学习，不仅会耗费很多宝贵精力，还会让你慢慢迷失。（我知道这一砖头扔出去，又会砸懵一片人。） 有些一起学习的小伙伴会问我，像阮一峰这样的大神好像什么都会，而且什么技术话题都能讲的很好。看他的博客感觉自己完全被碾压了，同样是24小时，为什么差距那么大？也有很多人问我：“你每天学习多长时间，能保持如此高的输出？” 其实这不是一个时间管理问题，而是认知效率问题。 群里的小伙伴问我，每天很努力的去学习，只要听说过的前端框架我都会去学习和琢磨，但是感觉就是没办法提升，也不被其他同事认可。 我问他：“你为什么学？现在学的什么？” 他说：“大家都学，比较慌，现在学习ng2。” 我问他：”学这个工作有用吗？“ 他说：”这个未来会有用处的，现在看起来没什么用处。” 我又问题：”有没有什么是你现在学习，明天就能用到工作中的哪？” 他回答不出来了，他根本没想过为什么学习和要学习什么才又用处。 我们从小听的最多的一句话是：“怎么又再玩，快去读书去！”。而你只要一读书，不管有多慢，不管你看的是地理还是历史，家长就不打扰你，仿佛你进入了正规，家长也看到了希望。久而久之，在你的思想里就形成了，只要学习，以后都会有用的。我在这明确告诉你，这个思路是错的。在知识匮乏的年代，就那么几本书，肯定是学比不学要好的多；但是在这个知识大爆炸时代、有目标的学习更重要。 介绍一个概念给你”认知效率”:认知收益和时间精力比。 同样的认知资源投入，会有完全不同的回报，这就是认知效率的不同。认知效率低对的人，都在做低水平的勤奋。牛人的真正秘诀是在最精华的资源上，以高很多倍的认知资源来学习，认知效率是你的很多倍。说白了，高手的技术就是”投入产出的非线性”。提高认知效率最有效的工具就是”极强的目的性“。 程序员使用功利学习法程序行业技术有个特点，就是新东西多，过时的也很快。如何摆脱困境？程序员学习有三个前提要求时效率最高，即有目标导向、有及时反馈、最近发展区。简单的说，能解决当下问题，学了有项目可用，难度适中的知识最有效。 为什么有的人看了三遍Vue的视频教程，还是不会用；当入职使用Vue的公司后，两周时间，已经可以上手项目。因为你入职后，Vue成为了你生存的刚需，每天上班就在使用，下班学习，一个开发任务接着一个开发任务。这种时候你三个条件都具备，效率就高，学得就快。这时候你就知道为什么我建议刚出校门的程序员不要读一些管理和营销书籍了吧，因为这些书对你目前来说，目的性弱，缺乏实践环境，且难度过高。这就时功利学习法，但是有些时候我们根本不具备这样的环境，又该如何学习那？这就是下面我要解决的问题。 小伙伴经常问我的问题：我们公司用的技术比较陈旧 ，还在使用jQuery和HTML，还要兼容IE8,我每天只是作切图布局，我该怎么提升？其实这就是你所处的环境不具备三个前提的情况，但是程序员的竞争对手不是在本公司，是全业界。我相信每个程序员学习都会遇到这个问题，你可以自己创造一个这样的环境，比如自己作一个开源的项目，然后在GitHub上不断维护，不断更新，来打造一个这样的环境。自我驱动，快速学习，这种自我驱动是有价值的，可以快速成长，获得名誉，甚至得到回报，比如尤雨溪（尤大神）就是靠着自己的开源项目登上中国前端程序界的第一人。当你不具备这个三个前提体条件时，要积极的为自己创造条件，让自己用 功利学习法开始学习。 不要从第一页开始读书为了引起你的重视，我要严肃的告诉你：最愚蠢的方式，就是直接找一本书打开第一页，然后依次往下读。 这就好像你到北京旅游，下了车谁也不问，谁也不找，直接出车站顺着一条道路就开始走。你这样的方法是不可能找到北京好玩的地方的，正确的做法是你应该在网上找找旅游攻略，或者是买个地图，然后坐上地铁直接去你想去的地方。这么说你很好理解，但是你读书却总犯这样的错误，从第一页开始读，希望能读到有用的东西（如果是基础书籍还好，比如犀牛和红宝书），但如果是一些畅销书，你也用这样的方法读书，那就太累了。 我的读书方法：先看书评，我一般会选择去豆瓣看书评，太专业的我会在群里（我群里已经4000多前端从业者）咨询一下看过这个本书的同行，让他们给一个客观的评价。然后把这个领域的书籍平衡比较一下，选择一本（如果经济条件允许的话，可以同时购买此类图书的全部内容，比如你要学vue，那就把Vue相关的所有书都买了）。拿到书后，先看一遍目录，然后用功利学习法只学习你需要的部分。 有很多小伙伴会觉的，从第一页开始看书更加系统。 第一：如果你脑子里没有框架，从第一页开始，把一本书看完，脑子里依然不会有框架。如果把系统比作大象，你的认知和记忆区间只是手掌，仅凭直线型的看书希望摸出知识系统，就如盲人摸象，如果你脑袋里没有全局，增加再多细节也没用。这就是你有些程序基础知识，已经完全吃透，但是还是没办法上手项目的主要原因。 第二：也许你并没有配置更加系统的认知资源和时间，很多书半途而废，可能更加不系统。想想你是不是还有很多技术书没有读完，或者你有一本书总是在看前200页。 用功利学习法读书，按需分配的读书，不从第一页开始读书，有了目的性、认知资源以及带着问题读的三个筛子，要读的书应该会减少75%，阅读速度会至少提升一倍，那样就不会有太多知识烦扰你了。 如果你开始用这种读书方法，并执行了一段时间你会发现问题。 最大的问题是我根本做不到这样读书，因为人的大脑是一个认知吝啬鬼，我们本能的选择最简单、最不耗脑子的方式，那就是拿起一本书开始看，并在脑袋里说：“读点儿书总没有错，大家都在读”。 功利学习法是在获得奖赏之前选择了延迟满足——先找到目标，调整好资源，带着问题进入。学会了功利学习法，你肯定可以跑赢90%的人。但好的方法都是逆人性的，能不能坚持下来，养成习惯是关键。 第六章：还在闭关修炼？我们已经华山论剑了古语有云：书中自有黄金屋，书中自有颜如玉。时代变了，如果你还是闭门死读，黄金屋早就让人过户了，颜如玉也和高富帅私奔了。在这个互通的时代，学习方式已经发生了本质的变化，也许你深受学校认知体系的毒害，蒙蔽了看清世界的双眼。 作为一个程序员联机学习非常重要（这章只说与人的联机）。 过去自己学自己悟，才是真本事。信息爆炸时代，“调用”和“整合”他人的答案，显然更加重要。过去一定要自己完全学通了，大彻大悟了才出来教别人。100分教5分的人，老师站着讲，学生“跪”着听；信息时代，往往15分的人教5分的人，大家商量着来，偶尔学生还能教老师几招。也许在一些老知识面前（比如：历史、化学、政治）前者更优，但在程序领域，每天都发生着变化的领域，后者显然更快，更好。 李小龙的快速崛起之道以下文字来源于网络 李小龙是第一位在国际舞台上屹立的华人巨星，更是功夫高手。李小龙对于武术界的影响，绝对不仅仅是泰森这种一代拳王对拳坛的影响，他还是一位开创者。他是武术思想家。他把哲学、健身、舞蹈、中国传统武术、跆拳道、空手道、菲律宾短棍术、柔术等相融合，形成一门独特的功夫。事实上，功夫的英文 “Kong Fu”,就是他创造的。《时代周刊》评选他为20世纪最伟大的100人之一。日本则尊称她为“武之圣者”。 要知道，李小龙刚到美国的时候，19岁，练习过几年咏春拳，但也不是最杰出的。而他24岁受邀作为嘉宾出席加州长堤国际空手道锦标赛，在唐人街打败其他中国武术高手时，已然有一代高手风范，期间只用了5年。是什么让他在短时间内，在武术思想和造诣上有那么快的发展？除天赋意外，他是怎么学习,从而快速成为高手的呢？ 李小龙也许是中国武术界第一个联机学习者。当时的武术界相对封闭，一人拜入某个流派，一日为师终身为父。未经允许学别家功夫就是欺师灭祖，更别说公开传授了。李小龙没有这种门派之见，大二开始他就租了个停车场开始教授咏春拳。这吸引了大量的功夫高手，他最早收的两名学生，一个练习柔道，一个练习空手道。李小龙不仅教授功夫，还教授课堂上刚学到的哲学和心理学，搭建起了自己的武术哲学体系。整合了传统中国武术和西方哲学心理学的这套功夫后，李小龙将其命名为截拳道。这是他传授给世界的第一个知识模块。 李小龙的截拳道是开放的，宗旨是“以无法为有法，以无极为有极”，没有门派之别。他经常从弟子那里学习他们的武术，迅速融合入截拳道又分享给更多弟子。 学习——理解——分享，是非常快速的小循环，李小龙的成功就得益于联机学习的模式。程序圈的大神，都在使用这样的联机学习法，超快速成长和扩大自己的影响圈。简单的说，想要快速学习，不是自己找大难，而是联机学习，“以答案换答案”。相比过去“学习——思考”的单机学习，这是一种镶嵌在社会网络之中的学习方式： 这种学习方法分为四个基本步骤（我也在用这种方法快速学习成长） 先高质量的输出自己的知识，形成一个知识模块； 然后找人开始谈，换回别人的知识模块； 不断重复前两步，积累足够多的知识模块； 整合出自己的知识体系，实现知识升级，进入行业头部。 你开始用这种方法学习时，你会很不舒服，因为他虐杀了我们原来的学习方法，并且需要很高的沟通能力。开始会感觉自己是行业小白，但是你只要把心态反正，你发现你的成长速度是最快的。 要想使用这种联机学习的本领，提问的技术一定高人一等，否则你是没办法拿到别人的知识模块的。 在这里传授一下提问的技术：1.问题要具体，准备要充分，目标要清晰。 我举个例子,是两个群里小伙伴给我发的。 第一个：老师，我想学成为前端大神，我读那些书好？推荐几本。 第二个：技术胖老师你好，我看完了你的大部分视频课程，学到了很多知识，已经上手项目。但是我想继续精进，我要求了京东所有前端的书籍，还综合了知乎的一些帖子，列了10本前端必读书，（书的列表省略）。我现在的情况是…….(讲述了很多学习困惑)，请你推荐一到两本最适合我的书，让我高效学习。 你会回答哪一个？我觉的第二个更努力，具体，指向清晰，我很愿意花一点时间去回答。在提问时，至少要先百度，然后看完前三页的内容，然后再去SegmentFault进行搜索（如果时认知类的，可以去知乎）。如果这两个都没找到答案，再提问。 2.好问题都是成串的如果你想向某人提问，你需要多花点时间，把问题想的更深入些，让问题形成一个串联。（这是快速进步的关键） 我下面推荐一下自己请教别人的小套路，你可以简单的把它当成模板。 “你觉得我真正入门人工智能得标准是什么？什么情况下知道一个人差不多入门了？有什么书可以推荐” “除了读书，这个领域还有那些方式可以让我快速成长？我想立体式快速学习” “如果我已经读完了这些书，我该做些什么项目让自己的认知再跳跃一步呢？” “像你这样的高手，对于这个领域未来5年的发展有什么洞见？” “还有谁你可以推荐给我认识，我们一起喝个咖啡。” 会不会很烦？如果你的问题会让对方烦，说明你提问的功力还不够，一个精心设计的问题会让对方很爽，因为他也没有 如此深入地思考过，这是一个整合的机会。你也许没办法达到别人的技术高度，但是你可以站在很高的地方提问。越是简单的问题，愿意回答的人越少。 3.输出问题，让别人看到你的成长问题跟输出有什么关系？试想一下，如果你一直帮助一个人，而那个人没有任何反馈或者进步，你还愿意帮助他吗？ 输出知识在提问中的好处： 可以帮助你把问题理顺，形成条理； 可以回馈帮助你的人，让他的知识更加具象，增加知名度； 我在工作中是个爱提问的人，提问也是我获取知识的一个主要手段。但输出是别人爱回答你的必要条件，所以当你在某个领域有所小成之后，一定要建立输出渠道，帮助更多的人，给帮助你的人正面反馈。 第七章：输出内容，让知识提升自我价值写了这么多，相信你已经掌握了一些学习的技巧，能够高效的学习了。但这些能力还是内化的，除了你身边的人可能没人知道你这么有才。但你看这篇文章的目的觉不是会学习，而是要成为IT领域的高手、某一方面的专家或是进入一线互联网公司。这时候我们需要输出知识，来提升自我价值，达到自己的目标。 其实输出知识我也在这几年才开始，但是见效很快，这完全的得益于IPO知识输出模型。 IPO知识输出模型 I：输入问题（Input a question），以持续解决问题为目标； P：解决问题（Problem solving），以整合所学知识为手段； O：输出产品(Output),通过咨询研发、授课整合和写作，让思想产品化； 这套系统在高手内部广为流传，大家都在使用，并且变现能力突出，程序界把这个模型叫整合知识的个人商业模式。我也在使用这种商业模型在不断迭代自己。 如何构建属于程序员的IPO：1、建立自己输出的阵地：这变的越来越容易了，在当今这个时代（也是自媒体的时代），你可以利用任何一个自媒体手段来输出内容。 博客：可以选择自建或者去CSDN申请一个，自建比较灵活，不受平台限制，但是前期基本没有流量，需要耐住性子（如果你是新手，不建议自建）。借助其他平台搭建，只要文章质量够高，还是不愁流量的，但这种流量归根到底属于平台，不属于自己，灵活性不高。 微信公众平台：个人申请简单，但自由度不好，还有就是我认为程序类自媒体不适合手机观看，所以用微信公众平台建立阵地个人感觉不妥。如果你是情感职业或者励志类的输出，微信公众平台是非常不错的选择，也是第一选择。所以微信公众平台也要重视，根据你说出内容的不同，自行选择。 专栏作者: 现在很多大型的IT程序网站都有专栏作者，比如CSDN、掘金、GitChat（已经被CSDN收购），如果能加入，对自己输出内容也是个不错的选择。当然专栏作者的进入是有点小门槛的，但是也不是那么高不可攀。其实当专栏作者还有一个最大的好处，就是你能通过专栏作者群认识很多业界出名的技术大佬（以后提问就在也不怕没人回答了）2、不是要学习知识，而是要解决问题 有了自己的输出问题，你主要的任务不是输出或者积累知识，而是帮助被人或者自己解决问题。我写这篇文章时，观察了很多前端小伙伴的博客，还处在自己学习的阶段，用简略的语言描述后，就是大篇幅的代码。如此输出知识，恐怕自己过一年后也看不明白，这就是典型的学习记录所用，并没有真正输出知识。 输出知识是要帮别人或者帮助自己解决问题，比如我写的博客和录的视频目的就是帮助人们解决看不懂API的问题，其实这些并没有什么高深，只是我把API吃透了，然后用容易让人接受的方式讲出来，帮助大家入门。当然这样作也是在为我自己解决问题，就是我在写博客的过程中，对录制的课程更加了解，让自己的知识模块晋升。一旦你能解决一个问题，就要尝试多解决同类型的问题，逐渐让这个解决方案能够应对不同情境，自我进化。 3、输出迭代，才能知识升级 把解决问题的知识形成文章，发布在自媒体上。只有这样你才能兑换价值，让更多人知道你有解决这类问题的能力。这个动作能帮助你找到下一轮更大的问题，以及更大的价值，形成迭代。只有不断把解决问题的能力输出，不断迭代，你的知识才能快速上涨，从而扩大自己的影响力，成为一个技术领域的专家 。 两个输出中的小坑：其实作输出不那么容易，很多人都有这个意识和想法，有的甚至已经走出了第一步，但最终都放弃了。在这里告诉大家两个下坑: 1、希望输出精品 最后片字未出产出不一定要大，但一定要有，永远不要低估一个正确的简单动作带来的可怕结果。如果写不出一本书，就写一篇文章；如果写不出文章，那就写一张知识卡片；如果没法积累一个知识卡片，那就总结一句话，然后分享出去（朋友圈为我们提供了最佳场所）。 这些话、卡片、文章和书积累到一定程度，就会逐渐成形，只要稍加修饰就能产生”个体之和大于整体”的效果，完成知识升级。当你打开新的话题，过去的知识作为一个模块，再整合进更多的知识，这样就形成了自己的知识体系。 2、害怕出丑 不愿分享我认识很多技术不错的程序员，他们都不愿意分享输出，害怕自己哗众取宠；还有些人不愿意分享，也不愿意帮助别人，觉得自己好不容易研究出来的事，怎么能一下子告诉你？ 其实最好检验自己水平或者说输入的方式，就是输出，而检验输出的最好方式就是帮助别人解决问题。我在工作中是非常愿意帮助别人解决问题的（网上实在是有心无力，一开QQ，上百条留言，如果都回答，我可能什么都不用干了。请小伙伴谅解！），帮别人解决问题，看似是他人”白白”获益，但是自己也重新打磨了知识，修正了很多错误，自己才是最大的受益人。 知识这东西也分享越多，如果你学会了，不分享，就烂在自己肚子里了，一分钱也不值。 在这里我也提供一个福利给大家，如果大家自己建立博客，博客原创内容超过100篇，可找技术胖作友链。 第八章：破局打造良性循环 自我增长引擎人生有很多局，一旦陷入局里来回重复，有些时候就变成了死亡循环（名字不太好听），至少会让你焦虑和浮躁。最重要的是，每个人自己的局里，你翻遍书也找不到标准答案。但如果不去破局，你的人生必将走向灰暗，碌碌无为度过一生。人生就是一次次的破局过程。（我相信看这篇文章的一定有大神，自己在生活的系统里，也不算破局高手。所以只是一点自己的认知，不能算作教程，有不对的地方多多包含！） 四种死亡循环局先来看一下生活或者工作中经常遇到的几个局： 穷者越穷循环贫穷有时候不是一种现象，而是一种习惯一种心态。如果你遇到一个很穷的人，给他500万，他可能在两三年后又变成一个穷人，这样的例子比比皆是。我就不具体点名指出了。 穷人的几个局: 忙——乱——忙 稀缺——没有资源想长远的事——稀缺 物质匮乏——诱惑多——自控力消耗——物质匮乏 上面这些都事穷者越穷的局，他们很难抽身出来，仿佛一切都无解，进入了一个穷循环局。 投入不足循环很多软件公司面临这样的问题：做出的软件销量不好导致研发投入不够，研发投入不够让竞争力进一步下降，公司还不愿意停下来，因为养着很多程序员和销售，一旦停下来大家都挨饿，老板就像坐在火山口上，惶惶不可终日。 现实中太多这样的公司了，他们的目标就是活着，但这样的活着真的又价值吗？ 工作狂循环工作狂和热爱工作是两回事，热爱工作是真心喜欢，而工作狂是不喜欢工作，但没办法控制。他们多是家庭不幸福，工作只是掩盖下班后的惶恐。 工作狂——家庭投入少——家庭没有成就感——工作狂 这是一个负增强循环，很多程序员人在公司很忙，对家里投入少，一点时间后，家人都对他又怨言。虽然说家庭很重要，但要顶着家人的怨气融入家庭，并不是件容易事，于是下意识地选择少回家。家人怨气因而更大，导致他回家次数越来越少。 作自己循环求认同——找不到自己——求认同 这也许是每个人的局，这个时代，人人都在努力的秀自己（我也不例外）。但“秀出自我”是一种毒。 很多人都希望找到最好的自己，不管是梦想还是天赋，内心的诉求是“求认同”。越是求认同，注意力就越放在外界的关注、也就是别人的看法，你越这样越难找到自己的天赋、梦想和激情。这也漩进了一种负循环中。其实你怎么可能通过讨好别人来做自己哪？ 正向循环的三种方法啰啰嗦嗦的说了半天，那如何避免这种死亡循环那？如果你遇到了死亡循环，先停下来，想清楚，这叫打断循环。那我再说四个建立正向循环的方法。 培养好习惯仔细观察，所谓的好习惯，本质就是那些能自增强的正循环的循环 。比如，持续学习的习惯，是”学习——成长——增值——学习”的循环；坚持锻炼的习惯，是”锻炼——精力充沛——锻炼”的循环；与人为善的习惯，是”善意——回报——善于”的循环。 鉴别一个习惯好不好，只需要看它是否能够形成正循环闭环。重要是这是一种持续的循环，最好每天都要作才好，如果你老是间断，就形不成循环。 从兴趣培养到能力养成因为对一件事感兴趣，投入足够多的时间练习，提升了能力；因为能力提高，所以更好的兑换了价值；因为有所回报，所以更加感兴趣；一个爱好逐渐养成了能力，甚至成为职业。 快速学习并输出产品通过思考问题、解决问题和输出产品，把自己的思考结果向外输出，从而吸引更多重要的问题输入，形成一个循环。目前所有程序高手都在努力跑通这个循环。 所以在我们的人生中，一定要有局的观念，多多审视自己所在的是正循环局还是负循环局。努力搭建正循环局，破坏负循环局，切断自毁线路。 本文来源：技术胖]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的搭搭建]]></title>
    <url>%2F2018%2F03%2F05%2Fhexo%E7%9A%84%E6%90%AD%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo的搭建第一步搭建环境Node.js的安装 官网下载 安装方式和一般软件一样 安装以及检查教程 git的安装 官网地址 使用和安装教程github帐号 如果有可以不用管，没有注册github帐号 创建完成以后移到头像旁边的加号，点击New repository今入创建代码库在Repository name下填写 yourname. github. io需注意: yourname要和你的Owner下显示的一致 第二步 安装hexo 创建需要的文件夹，例如：hexo 在hexo文件下右键打开Git Bash Here在命令行中输入 npm install hexo -g 如图：输入 hexo -v 检查是否安装 初始化hexo init 启动hexo服务npm install hexo clean // 清除缓存 hexo generate // 生成 hexo deploy // 开始部署 本地预览不需要启动 hexo server // 启动服务预览 浏览器输入http://localhost:4000 就可以看到页面此时页面 第三步 Hexo与github关联配置hexo 修改hexo主目录下的_config.yml文件的deploy添加如下代码 1234deploy: type: git repository:git@github.com:name/name.github.io.git branch: master 注意：name为你自己的地址，冒号后是空格 配置git信息 创建ssh 1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 检查是否有ssh key 1cd ~/.ssh // 检查本机的ssh密钥 注意： No such file or directory 说明你是第一次使用 git 在github中添加ssh key 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，或者直接在控制台输入cat id_rsa.pub然后进入https://github.com/settings/ssh 点击New SSH key 粘贴到key中，title随便填 点击Add SSH key即可 输入ssh -T git@github.com 验证是否添加成功 设置git的username 和 email 12git config -g user.nmae &apos;username&apos;git config -g user.email &apos;useremail@xx.com&apos; 注意 引号中的填写自己的 进入文件的根目录打开git bash here 分别执行 123hexo cleanhexo generatehexo server 上传到github 先安装 npm install hexo-deployer-git –save执行 123hexo cleanhexo generatehexo deploy // 会有弹框提示登录github，输入用户名密码即可 错误：如果hexo d 报错 就运行命令npm install hexo-deployer-git –save操作： 之后的预览上传用 简写12hexo s -g //预览hexo d -g // 部署 参考文档地址：https://www.cnblogs.com/visugar/p/6821777.html http://blog.csdn.net/qwerty200696/article/details/78997530]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测加密文档]]></title>
    <url>%2F2018%2F03%2F05%2Fpassword%2F</url>
    <content type="text"></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[title]]></title>
    <url>%2F2018%2F03%2F05%2Ftitle%2F</url>
    <content type="text"><![CDATA[初次使用hexo]]></content>
      <categories>
        <category>Hexo教程</category>
      </categories>
  </entry>
</search>
